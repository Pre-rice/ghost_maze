<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>鬼迷宫</title>
        <style>
        :root {
            --bg-color: #f0f2f5;
            --danger-bg-color: #680e0e;
            --container-bg: #ffffff;
            --text-color: #333;
            --border-color: #d9d9d9;
            --primary-color: #1890ff;
            --primary-hover-color: #40a9ff;
            --danger-color: #ff4d4f;
            --danger-hover-color: #ff7875;
            --success-color: #52c41a;
            --disabled-color: #f5f5f5;
            --disabled-text-color: #bfbfbf;

            /* Game Colors */
            --ground-color: #dfe3e6;
            --grid-line-color: #dadee1;
            --unexplored-color: #0b0b0b;
            --wall-color: #495360;
            --player-color: #007bff;
            --ghost-color: #dc3545;
            --end-point-color: #28a745;
            --key-color: #ffc107;
            --start-room-highlight: rgba(173, 216, 230, 0.4);
            --hover-highlight-color: #ffc107;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.25s ease; /* Faster transition */
        }

        body.danger-bg {
            background-color: var(--danger-bg-color);
        }

        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #game-canvas {
            border: 1px solid var(--border-color);
            background-color: var(--container-bg);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: pointer;
        }

        .controls-panel {
            width: 280px;
            padding:15px;
            background-color: var(--container-bg);
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 6px;
        }

        .control-group h3 {
            margin: 0;
            font-size: 16px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        
        .control-group .status-bar {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .control-group label, .control-group .label {
            font-weight: 500;
            font-size: 14px;
        }

        #ghost-proximity-display.warning {
            color: var(--danger-color);
            font-weight: bold;
        }

        .control-group input[type="number"], .control-group input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }

        button, .button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: var(--primary-color);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
        }

        button:hover, .button:hover {
            background-color: var(--primary-hover-color);
        }
        
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
        
        button.danger {
            background-color: var(--danger-color);
        }
        button.danger:hover {
            background-color: var(--danger-hover-color);
        }

        button:disabled {
            background-color: var(--disabled-color);
            color: var(--disabled-text-color);
            cursor: not-allowed;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle-switch input[type="checkbox"] {
            height: 0;
            width: 0;
            visibility: hidden;
        }

        .toggle-switch label {
            cursor: pointer;
            text-indent: -9999px;
            width: 50px;
            height: 25px;
            background: grey;
            display: block;
            border-radius: 100px;
            position: relative;
        }

        .toggle-switch label:after {
            content: '';
            position: absolute;
            top: 2.5px;
            left: 2.5px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 90px;
            transition: 0.3s;
        }

        .toggle-switch input:checked + label {
            background: var(--primary-color);
        }

        .toggle-switch input:checked + label:after {
            left: calc(100% - 2.5px);
            transform: translateX(-100%);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .overlay-content {
            background-color: var(--container-bg);
            padding: 30px 40px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .overlay-content h2, .overlay-content p {
            margin-top: 0;
            margin-bottom: 1em;
        }

        .overlay-content .buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .editor-toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .share-buttons-container {
            display: flex;
            gap: 10px;
        }
        .share-buttons-container button {
            flex: 1; /* 让两个按钮平分宽度 */
        }
        
        .editor-toolbar button.active {
            background-color: var(--primary-hover-color);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* === Toast Notification Styles === */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translate(-50%, -100px);
            padding: 12px 20px;
            border-radius: 6px;
            background-color: var(--primary-color);
            color: white;
            font-size: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: transform 0.4s ease, opacity 0.4s ease, visibility 0.4s;
        }
        .toast.show {
            transform: translate(-50%, 0);
            opacity: 1;
            visibility: visible;
        }
        .toast.success {
            background-color: var(--success-color);
        }
        .toast.error {
            background-color: var(--danger-color);
        }
        /* === 新增：用于将标签和输入框放在一行的样式 === */
        .inline-control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px; /* 在标签和输入框之间增加一点间距 */
        }
        /* === 新增：限制行内输入框的宽度，使其不再占满剩余空间 === */
        .inline-control-group input[type="number"] {
            width: 50%; /* 设置输入框宽度为父容器的一半 */
        }
        #game-canvas {
         -webkit-tap-highlight-color: transparent; /* 核心改动：移除移动端点击时的蓝色高亮效果 */
        }
        
        /* === 新增：模式选择器样式 === */
        .mode-selector {
            display: flex;
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }
        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background-color: var(--container-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border-radius: 0;
        }
        .mode-btn:not(:last-child) {
            border-right: 1px solid var(--border-color);
        }
        .mode-btn.active {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
        .mode-btn:not(.active):hover {
            background-color: #f0f0f0;
        }

        /* === 移动端适配媒体查询 === */
        /* 当屏幕宽度小于等于 768px 时，应用以下样式 */
        @media (max-width: 768px) {
            body {
                padding: 10px; /* 为小屏幕调整内边距，避免内容紧贴边缘 */
                align-items: flex-start; /* 恢复默认的顶部对齐 */
            }

            .main-container {
                flex-direction: column; /* 核心改动：将主容器的布局从水平并排变为垂直堆叠 */
                gap: 15px; /* 调整画布和控制面板垂直堆叠时的间距 */
                width: 100%;
            }

            #game-canvas {
                width: 100%; /* 让画布宽度占满容器宽度 */
                height: auto; /* 高度自动调整，以保持其原始的1:1宽高比 */
                order: 1; /* 视觉上确保画布在控制面板的上方 */
            }

            .controls-panel {
                width: 100%; /* 控制面板也占满容器宽度 */
                order: 2; /* 视觉上确保控制面板在画布的下方 */
                padding: 15px; /* 可以在小屏幕上稍微减少一点内边距 */
                box-sizing: border-box; /* 确保padding不会撑大宽度 */
            }

            /* 调整游戏结束、胜利等浮窗在小屏幕上的表现 */
            .overlay-content {
                padding: 20px 15px;
                width: 90%; /* 避免浮窗宽度紧贴屏幕边缘 */
                box-sizing: border-box;
            }

            .overlay-content h2 {
                font-size: 1.5rem; /* 适当调整标题字体大小 */
            }

            /* 在小屏幕上，浮窗里的按钮也垂直堆叠，更易于点击 */
            .overlay-content .buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .overlay-content .buttons button {
                width: 100%; /* 让每个按钮都更容易点击 */
            }
            
            /* 调整编辑器工具栏，允许其在空间不足时换行并居中 */
            .editor-toolbar {
                justify-content: center;
            }

        @media (max-width: 768px) {
            #dpad-controls {
                display: grid !important;
                grid-template-columns: 60px 60px 60px;
                grid-template-rows: 60px 60px 60px;
                position: fixed;
                bottom: 20px;
                right: 20px;
                opacity: 0.7;
                z-index: 100;
                background-color: transparent;
                touch-action: none;
                transform-origin: center center;
            }

            .dpad-btn {
                background-color: #333;
                color: white;
                border: 2px solid #555;
                border-radius: 10px;
                font-size: 24px;
                display: flex;
                justify-content: center;
                align-items: center;
                user-select: none;
                -webkit-user-select: none;
                cursor: pointer;
            }

            #dpad-up { grid-column: 2; grid-row: 1; }
            #dpad-down { grid-column: 2; grid-row: 3; }
            #dpad-left { grid-column: 1; grid-row: 2; }
            #dpad-right { grid-column: 3; grid-row: 2; }
            
            /* === 新增: 拖动把手的样式 === */
            #dpad-grip {
                grid-column: 2;
                grid-row: 2;
                background-color: rgba(85, 85, 85, 0.8);
                border-radius: 50%;
                cursor: move;
                border: 2px solid #333;
            }

            .dpad-btn:active {
                background-color: #555;
                transform: scale(0.95);
            }
        }
        }

/* 1. 开关父容器的基础布局 */
.toggle-controls-wrapper {
    display: flex;
    align-items: center;
    gap: 15px; /* 仅在移动端两个开关并存时生效 */
    /* 默认靠左对齐，适用于电脑端只有一个开关的情况 */
    justify-content: flex-start; 
}

/* 2. 每个开关的基础样式 */
.toggle-controls-wrapper .toggle-switch {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%; /* 默认让开关占满父容器宽度 */
}

/* 3. 默认隐藏方向键开关 */
#dpad-toggle-container {
    display: none;
}

/* 4. 仅在移动端 (屏幕宽度 <= 768px) 应用特殊布局 */
@media (max-width: 768px) {
    /* 在移动端，让父容器的对齐方式变为 space-between */
    .toggle-controls-wrapper {
        justify-content: space-between;
    }

    /* 在移动端，让每个开关只占大约一半的宽度 */
    .toggle-controls-wrapper .toggle-switch {
        width: 48%;
    }

    /* 在移动端，显示方向键开关 */
    #dpad-toggle-container {
        display: flex;
    }
}

/* 用于通过JS来强制隐藏方向键的类 */
#dpad-controls.hidden {
    display: none !important;
}
    </style>
    </head>
    <body>

        <div class="main-container">
            <canvas id="game-canvas" width="600" height="600"></canvas>

            <div class="controls-panel">
                <!-- Game Mode UI -->
                <div id="game-controls">
                    <div class="control-group">
                        <h3>状态</h3>
                        <!-- 探索模式状态栏 -->
                        <div id="status-bar-exploration" class="status-bar">
                            <div id="player-health-display" class="label">生命:
                                5</div>
                            <div id="player-keys-display" class="label">钥匙:
                                0</div>
                            <div id="player-steps-display" class="label">步数:
                                0</div>
                            <div id="ghost-proximity-display"
                                class="label">周围鬼数: 0</div>
                        </div>
                        <!-- 死亡循环模式状态栏 -->
                        <div id="status-bar-death-loop" class="status-bar"
                            style="display: none;">
                            <div id="loop-count-display" class="label">循环次数:
                                0</div>
                            <div id="player-keys-display-death-loop"
                                class="label">钥匙: 0</div>
                            <div id="player-stamina-display" class="label">剩余体力:
                                100</div>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>控制</h3>
                        <div class="share-buttons-container">
                            <button id="undo-btn" class="secondary">撤回</button>
                            <button id="save-btn" class="secondary">存档</button>
                            <button id="rewind-btn"
                                class="secondary">回溯</button>
                        </div>
                        <div class="toggle-controls-wrapper">
                            <div class="toggle-switch">
                                <span class="label">调试视野</span>
                                <input type="checkbox" id="debug-vision-toggle">
                                <label for="debug-vision-toggle">Toggle</label>
                            </div>
                            <div id="dpad-toggle-container"
                                class="toggle-switch">
                                <span class="label">方向按键</span>
                                <input type="checkbox" id="dpad-toggle" checked>
                                <label for="dpad-toggle">Toggle</label>
                            </div>
                        </div>
                        <button id="generate-map-btn">随机生成新地图</button>
                        <button id="reset-map-btn">重置地图</button>
                    </div>

                    <div class="control-group">
                        <h3>地图选项</h3>
                        <label class="label">模式选择</label>
                        <div class="mode-selector">
                            <button id="mode-exploration-btn"
                                class="mode-btn active">探索模式</button>
                            <button id="mode-death-loop-btn"
                                class="mode-btn">死亡循环</button>
                        </div>
                        <div class="inline-control-group">
                            <label for="map-size-input">地图大小 (8-20):</label>
                            <input type="number" id="map-size-input" value="10"
                                min="8" max="20">
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>分享</h3>
                        <div class="share-buttons-container">
                            <button id="copy-share-code-btn">复制分享码</button>
                            <button id="load-share-code-btn">粘贴并加载</button>
                        </div>
                    </div>

                    <div class="control-group">
                        <h3>编辑器</h3>
                        <button id="edit-map-btn">编辑地图</button>
                    </div>
                </div>

                <!-- Editor Mode UI -->
                <div id="editor-controls" style="display: none;">
                    <div class="control-group">
                        <h3>编辑器工具</h3>
                        <div class="editor-toolbar">
                            <button id="tool-wall"
                                class="tool-btn active">墙壁</button>
                            <button id="tool-glass" class="tool-btn">玻璃</button>
                            <button id="tool-door" class="tool-btn">门</button>
                            <button id="tool-oneway"
                                class="tool-btn">单向门</button>
                            <button id="tool-lock" class="tool-btn">数字门</button>
                            <button id="tool-letter"
                                class="tool-btn">字母门</button>
                            <button id="tool-button"
                                class="tool-btn">按钮</button>
                            <button id="tool-ghost" class="tool-btn">鬼</button>
                            <button id="tool-key" class="tool-btn">钥匙</button>
                            <button id="tool-end" class="tool-btn">终点</button>
                            <button id="tool-eraser"
                                class="tool-btn">橡皮擦</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>地图选项</h3>
                        <label class="label">游戏模式</label>
                        <div class="mode-selector">
                            <button id="editor-mode-exploration-btn"
                                class="mode-btn active">探索模式</button>
                            <button id="editor-mode-death-loop-btn"
                                class="mode-btn">死亡循环</button>
                        </div>
                        <div class="inline-control-group">
                            <label for="editor-map-size-input">地图大小
                                (8-20):</label>
                            <input type="number" id="editor-map-size-input"
                                value="10" min="8" max="20">
                        </div>
                        <div id="initial-health-container"
                            class="inline-control-group">
                            <label for="editor-initial-health">初始生命:</label>
                            <input type="number" id="editor-initial-health"
                                value="5" min="1">
                        </div>
                        <div id="initial-stamina-container"
                            class="inline-control-group" style="display: none;">
                            <label for="editor-initial-stamina">初始体力:</label>
                            <input type="number" id="editor-initial-stamina"
                                value="100" min="1">
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>控制</h3>
                        <button id="play-edited-map-btn">游玩地图</button>
                        <button id="clear-map-btn" class="danger">清空地图</button>
                    </div>
                    <div class="control-group">
                        <h3>分享</h3>
                        <div class="share-buttons-container">
                            <button
                                id="editor-copy-share-code-btn">复制分享码</button>
                            <button
                                id="editor-load-share-code-btn">粘贴并加载</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Overlays -->
        <div id="death-overlay" class="overlay">
            <div class="overlay-content">
                <h2 id="death-message">你死了</h2>
                <div class="buttons">
                    <button id="revive-btn">复活</button>
                </div>
            </div>
        </div>

        <div id="game-over-overlay" class="overlay">
            <div class="overlay-content">
                <h2>你死了，游戏结束</h2>
                <div class="buttons">
                    <button id="game-over-replay-btn">再次游玩该地图</button>
                    <button id="game-over-new-map-btn">游玩新地图</button>
                </div>
            </div>
        </div>

        <div id="win-overlay" class="overlay">
            <div class="overlay-content">
                <h2>你赢了！</h2>
                <p id="win-stats"></p>
                <div class="buttons">
                    <button id="win-replay-btn">再次游玩该地图</button>
                    <button id="win-new-map-btn">游玩新地图</button>
                </div>
            </div>
        </div>

        <!-- Custom Confirm Overlay -->
        <div id="confirm-overlay" class="overlay">
            <div class="overlay-content">
                <p id="confirm-message">你确定吗？</p>
                <div class="buttons">
                    <button id="confirm-yes-btn" class="danger">确认</button>
                    <button id="confirm-no-btn" class="secondary">取消</button>
                </div>
            </div>
        </div>

        <!-- Toast Notification -->
        <div id="toast-notification" class="toast"></div>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
        <script>
    // ==================================================
    //  常量定义
    // ==================================================
    const WALL_TYPES = {
        EMPTY: 0,
        SOLID: 1,
        DOOR: 2,
        LOCKED: 3,
        ONE_WAY: 4,
        GLASS: 5,
        LETTER_DOOR: 6
    };

    const GAME_STATES = {
        MENU: 'menu',
        PLAYING: 'playing',
        DEAD: 'dead',
        WON: 'won',
        EDITOR: 'editor'
    };

    const EDITOR_TOOLS = {
        WALL: 'wall',
        GLASS: 'glass',
        DOOR: 'door',
        ONE_WAY: 'oneway',
        LOCK: 'lock',
        LETTER_DOOR: 'letter',
        BUTTON: 'button',
        GHOST: 'ghost',
        KEY: 'key',
        END: 'end',
        ERASER: 'eraser'
    };

    // 监听DOM内容加载完成事件，确保在操作DOM之前所有元素都已准备好
    document.addEventListener('DOMContentLoaded', () => {
        // 获取Canvas元素及其2D渲染上下文
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        /**
         * 游戏主类，封装了所有游戏逻辑、状态和UI交互
         */
        class GhostMazeGame {
            constructor() {
                // 缓存常用的DOM元素引用，提高性能
                this.healthDisplay = document.getElementById('player-health-display');
                this.keysDisplay = document.getElementById('player-keys-display');
                this.stepsDisplay = document.getElementById('player-steps-display');
                this.ghostProximityDisplay = document.getElementById('ghost-proximity-display');
                this.mapSizeInput = document.getElementById('map-size-input');
                this.editorMapSizeInput = document.getElementById('editor-map-size-input');
                this.toastElement = document.getElementById('toast-notification');
                this.confirmOverlay = document.getElementById('confirm-overlay');
                this.confirmMessage = document.getElementById('confirm-message');
                this.confirmYesBtn = document.getElementById('confirm-yes-btn');
                this.confirmNoBtn = document.getElementById('confirm-no-btn');
                
                // 用于管理定时器和动画帧的ID
                this.toastTimeout = null;
                this.animationFrameId = null;
                this.autoMoveInterval = null;
                this.dpadInterval = null;

                // 为静态背景层创建离屏Canvas，用于性能优化
                this.staticLayerCanvas = document.createElement('canvas');
                this.staticLayerCtx = this.staticLayerCanvas.getContext('2d');
                
                // 从CSS变量中获取颜色值，便于在Canvas绘图中统一风格
                const computedStyle = getComputedStyle(document.documentElement);
                this.colors = {
                    ground: computedStyle.getPropertyValue('--ground-color').trim(),
                    gridLine: computedStyle.getPropertyValue('--grid-line-color').trim(),
                    unexplored: computedStyle.getPropertyValue('--unexplored-color').trim(),
                    wall: computedStyle.getPropertyValue('--wall-color').trim(),
                    player: computedStyle.getPropertyValue('--player-color').trim(),
                    ghost: computedStyle.getPropertyValue('--ghost-color').trim(),
                    endPoint: computedStyle.getPropertyValue('--end-point-color').trim(),
                    key: computedStyle.getPropertyValue('--key-color').trim(),
                    startRoomHighlight: computedStyle.getPropertyValue('--start-room-highlight').trim(),
                    hoverHighlight: computedStyle.getPropertyValue('--hover-highlight-color').trim()
                };
                
                // 核心游戏状态
                this.state = GAME_STATES.MENU;
                this.gameMode = 'exploration';
                this.initialHealth = 5;
                this.initialStamina = 100;
                this.loopCount = 0;
                this.width = 10;
                this.height = 10;
                this.cellSize = canvas.width / this.width;
                this.mapData = null;

                // 玩家状态
                this.player = { x: 1, y: 1, hp: 5, stamina: 100, trail: [], keys: 0 , steps: 0};

                // 鬼和物品
                this.ghosts = [];
                this.ghostCount = 3;
                this.items = [];
                this.buttons = [];

                // 地图结构数据
                this.hWalls = [];
                this.vWalls = [];
                this.startPos = { x: 1, y: 1 };
                this.endPos = { x: 0, y: 0 };
                
                // 视野系统
                this.seenCells = [];
                this.debugVision = false;

                // 编辑器状态
                this.editor = {
                    active: false,
                    tool: EDITOR_TOOLS.WALL,
                    isDragging: false,
                    didDrag: false,
                    dragAxis: null,
                    lastDragPos: null,
                    hoveredWall: null,
                    hoveredButtonHotspot: null
                };

                // 历史记录系统状态
                this.history = [];
                this.checkpoints = [];
                this.currentStep = -1;

                // 移动端虚拟方向键(D-pad)状态
                this.dpad = {
                    element: document.getElementById('dpad-controls'),
                    grip: document.getElementById('dpad-grip'),
                    isDragging: false,
                    isResizing: false,
                    startX: 0,
                    startY: 0,
                    initialLeft: 0,
                    initialTop: 0,
                    initialDist: 0,
                    currentScale: 1
                };

                // 绑定所有UI事件并显示初始欢迎信息
                this.bindUI();
                this.showInitialMessage();
                // 页面加载时尝试从 URL 查询参数或 hash 读取分享码
            this.loadShareCodeFromURL();
            }
            
            /**
            * 从 URL 自动解析分享码，例如：
            *   https://xxx.com/?map=xxxx
            *   https://xxx.com/#xxxx
            * 自动加载地图。
            */
            loadShareCodeFromURL() {
                // 1. 从 ?map= 获取
                const params = new URLSearchParams(window.location.search);
                let code = params.get("map");

                // 2. 若没有，从 #hash 获取
                if (!code && window.location.hash) {
                    code = window.location.hash.substring(1);
                }

                if (!code) return;  // URL 没有分享码，则不处理

                this.showToast("检测到分享码，正在加载…", 2000);

                try {
                    this.loadFromShareCode(code);
                } catch (e) {
                    console.error(e);
                    this.showToast("分享码无效或无法解析", 3000, "error");
                }
            }

            /**
             * 在游戏开始前，在Canvas上显示欢迎信息
             */
            showInitialMessage() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'black';
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('点击 "随机生成新地图" 或加载分享码开始游戏', canvas.width / 2, canvas.height / 2);
            }

            // ==================================================
            //  UI绑定与控制
            // ==================================================

            /**
             * 绑定所有HTML元素的事件监听器
             */
            bindUI() {
                // 游戏控制按钮
                document.getElementById('generate-map-btn').addEventListener('click', () => this.generateNewRandomMap());
                document.getElementById('reset-map-btn').addEventListener('click', () => this.resetCurrentMap());
                document.getElementById('edit-map-btn').addEventListener('click', () => this.enterEditorMode());

                // 分享码功能按钮 (主界面和编辑器)
                document.getElementById('copy-share-code-btn').addEventListener('click', () => this.copyShareCode());
                document.getElementById('editor-copy-share-code-btn').addEventListener('click', () => this.copyShareCode(true));
                document.getElementById('load-share-code-btn').addEventListener('click', () => this._loadCodeFromClipboard(false));
                document.getElementById('editor-load-share-code-btn').addEventListener('click', () => this._loadCodeFromClipboard(true));

                // 调试视野开关
                document.getElementById('debug-vision-toggle').addEventListener('change', (e) => {
                    this.debugVision = e.target.checked;
                    this.draw();
                    if (this.state === GAME_STATES.PLAYING) {
                        this.updateProximityWarning();
                    }
                });

                // 游戏模式选择按钮
                document.getElementById('mode-exploration-btn').addEventListener('click', () => this.setGameMode('exploration'));
                document.getElementById('mode-death-loop-btn').addEventListener('click', () => this.setGameMode('death-loop'));
                document.getElementById('editor-mode-exploration-btn').addEventListener('click', () => this.setGameMode('exploration', true));
                document.getElementById('editor-mode-death-loop-btn').addEventListener('click', () => this.setGameMode('death-loop', true));

                // 游戏结束/胜利浮窗中的按钮
                document.getElementById('revive-btn').addEventListener('click', () => this.revivePlayer());
                document.getElementById('game-over-replay-btn').addEventListener('click', () => this.resetCurrentMap());
                document.getElementById('game-over-new-map-btn').addEventListener('click', () => this.generateNewRandomMap());
                document.getElementById('win-replay-btn').addEventListener('click', () => this.resetCurrentMap());
                document.getElementById('win-new-map-btn').addEventListener('click', () => this.generateNewRandomMap());

                // 编辑器工具栏按钮
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.setEditorTool(e.target.id.split('-')[1]));
                });
                this.editorMapSizeInput.addEventListener('change', () => this.resizeAndClearEditor());
                document.getElementById('play-edited-map-btn').addEventListener('click', () => this.playEditedMap());
                document.getElementById('clear-map-btn').addEventListener('click', () => this.clearEditorMap());
                
                // 全局键盘事件
                window.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Canvas上的鼠标事件 (主要用于编辑器和玩家点击移动)
                canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));
                canvas.addEventListener('mouseleave', (e) => this.handleCanvasMouseLeave(e));

                // Canvas上的触摸事件 (移动端编辑器支持)
                const handleTouchStart = (e) => {
                    if (this.editor.active) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        this.handleCanvasMouseDown(touch);
                    }
                };
                const handleTouchMove = (e) => {
                    if (this.editor.active) {
                        e.preventDefault();
                        const touch = e.touches[0];
                        this.handleCanvasMouseMove(touch);
                    }
                };
                const handleTouchEnd = (e) => {
                    if (this.editor.active) {
                        e.preventDefault();
                        const touch = e.changedTouches[0];
                        this.handleCanvasMouseUp(touch);
                    }
                };
                canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
                canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
                canvas.addEventListener('touchend', handleTouchEnd, { passive: false });
                canvas.addEventListener('touchcancel', handleTouchEnd, { passive: false });

                // 虚拟方向键(D-pad)相关绑定
                this.bindDpadControls();
                document.getElementById('dpad-toggle').addEventListener('change', (e) => {
                    this.updateDpadVisibility();
                });
                this.initializeDpadTouchControls();

                // 历史记录系统按钮
                document.getElementById('undo-btn').addEventListener('click', () => this.handleUndo());
                document.getElementById('save-btn').addEventListener('click', () => this.handleSave());
                document.getElementById('rewind-btn').addEventListener('click', () => this.handleRewind());
            }

            /**
             * 初始化虚拟方向键的拖动和缩放功能
             */
            initializeDpadTouchControls() {
                const dpad = this.dpad;

                // 从localStorage加载并应用上次保存的位置和大小
                const savedLeft = localStorage.getItem('dpadLeft');
                const savedTop = localStorage.getItem('dpadTop');
                const savedScale = localStorage.getItem('dpadScale');

                if (savedScale) {
                    dpad.currentScale = parseFloat(savedScale);
                    dpad.element.style.transform = `scale(${dpad.currentScale})`;
                }
                if (savedLeft && savedTop) {
                    dpad.element.style.left = savedLeft;
                    dpad.element.style.top = savedTop;
                    dpad.element.style.right = 'auto';
                    dpad.element.style.bottom = 'auto';
                }

                // 辅助函数，确保D-pad使用JS计算的绝对定位
                const ensureJsPositioning = () => {
                    if (dpad.element.style.left === '' || dpad.element.style.top === '') {
                        const rect = dpad.element.getBoundingClientRect();
                        dpad.element.style.left = `${rect.left}px`;
                        dpad.element.style.top = `${rect.top}px`;
                        dpad.element.style.right = 'auto';
                        dpad.element.style.bottom = 'auto';
                    }
                };

                // 绑定单指拖动事件到中心把手
                dpad.grip.addEventListener('touchstart', (e) => {
                    const touches = e.touches;
                    if (touches.length === 1) {
                        e.preventDefault();
                        ensureJsPositioning();
                        dpad.isDragging = true;
                        dpad.startX = touches[0].clientX;
                        dpad.startY = touches[0].clientY;
                        dpad.initialLeft = parseFloat(dpad.element.style.left);
                        dpad.initialTop = parseFloat(dpad.element.style.top);
                    }
                }, { passive: false });

                // 绑定双指缩放事件到整个D-pad容器
                dpad.element.addEventListener('touchstart', (e) => {
                    const touches = e.touches;
                    if (touches.length === 2) {
                        e.preventDefault();
                        ensureJsPositioning();
                        dpad.isResizing = true;
                        const dx = touches[0].clientX - touches[1].clientX;
                        const dy = touches[0].clientY - touches[1].clientY;
                        dpad.initialDist = Math.sqrt(dx * dx + dy * dy);
                    }
                }, { passive: false });

                // 监听全局触摸移动事件
                document.addEventListener('touchmove', (e) => {
                    if (!dpad.isDragging && !dpad.isResizing) return;
                    e.preventDefault();
                    const touches = e.touches;

                    if (dpad.isDragging && touches.length === 1) { // 处理拖动
                        const dx = touches[0].clientX - dpad.startX;
                        const dy = touches[0].clientY - dpad.startY;
                        dpad.element.style.left = `${dpad.initialLeft + dx}px`;
                        dpad.element.style.top = `${dpad.initialTop + dy}px`;
                    } else if (dpad.isResizing && touches.length === 2) { // 处理缩放
                        const dx = touches[0].clientX - touches[1].clientX;
                        const dy = touches[0].clientY - touches[1].clientY;
                        const currentDist = Math.sqrt(dx * dx + dy * dy);
                        const scaleChange = currentDist / dpad.initialDist;
                        let newScale = dpad.currentScale * scaleChange;
                        newScale = Math.max(0.5, Math.min(2.5, newScale)); // 限制缩放范围
                        dpad.element.style.transform = `scale(${newScale})`;
                    }
                }, { passive: false });

                // 监听全局触摸结束事件，保存状态
                document.addEventListener('touchend', (e) => {
                    if (dpad.isResizing) {
                        const transformStyle = dpad.element.style.transform;
                        const scaleMatch = transformStyle.match(/scale\((.+)\)/);
                        if (scaleMatch) {
                            dpad.currentScale = parseFloat(scaleMatch[1]);
                        }
                        localStorage.setItem('dpadScale', dpad.currentScale);
                    }
                    if (dpad.isDragging) {
                        localStorage.setItem('dpadLeft', dpad.element.style.left);
                        localStorage.setItem('dpadTop', dpad.element.style.top);
                    }
                    dpad.isDragging = false;
                    dpad.isResizing = false;
                });
            }

            /**
             * 设置游戏模式并更新相关的UI显示
             * @param {string} newMode - 新的游戏模式 ('exploration' 或 'death-loop')
             * @param {boolean} fromEditor - 调用是否来自编辑器界面
             */
            setGameMode(newMode, fromEditor = false) {
                if (this.gameMode === newMode && !fromEditor) return;
                this.gameMode = newMode;

                const isExploration = newMode === 'exploration';

                // 更新主界面和编辑器界面中模式按钮的激活状态
                document.getElementById('mode-exploration-btn').classList.toggle('active', isExploration);
                document.getElementById('mode-death-loop-btn').classList.toggle('active', !isExploration);
                document.getElementById('editor-mode-exploration-btn').classList.toggle('active', isExploration);
                document.getElementById('editor-mode-death-loop-btn').classList.toggle('active', !isExploration);

                // 根据模式切换显示对应的状态栏
                document.getElementById('status-bar-exploration').style.display = isExploration ? 'flex' : 'none';
                document.getElementById('status-bar-death-loop').style.display = isExploration ? 'none' : 'flex';

                // 根据模式切换编辑器中显示初始生命/体力输入框
                document.getElementById('initial-health-container').style.display = isExploration ? 'flex' : 'none';
                document.getElementById('initial-stamina-container').style.display = isExploration ? 'none' : 'flex';

                // 如果在游戏中切换模式，则重置当前地图
                if (this.state !== GAME_STATES.MENU && this.state !== GAME_STATES.EDITOR) {
                    this.resetCurrentMap();
                }
                this.updateUIDisplays();
            }

            /**
             * 根据开关状态和游戏模式更新虚拟方向键的可见性
             */
            updateDpadVisibility() {
                const dpadToggle = document.getElementById('dpad-toggle');
                const dpadControls = document.getElementById('dpad-controls');
                const shouldShow = dpadToggle.checked && !this.editor.active;

                if (shouldShow) {
                    dpadControls.classList.remove('hidden');
                } else {
                    dpadControls.classList.add('hidden');
                }
            }

            /**
             * 绑定虚拟方向键按钮的触摸和点击事件
             */
            bindDpadControls() {
                const upBtn = document.getElementById('dpad-up');
                const downBtn = document.getElementById('dpad-down');
                const leftBtn = document.getElementById('dpad-left');
                const rightBtn = document.getElementById('dpad-right');

                // 按下按钮时的处理函数，支持长按连续移动
                const handleDpadPress = (dx, dy) => {
                    if (this.state !== GAME_STATES.PLAYING) return;
                    clearInterval(this.autoMoveInterval);
                    clearInterval(this.dpadInterval);
                    this.movePlayer(dx, dy); // 立即移动一次
                    this.dpadInterval = setInterval(() => { // 设置定时器实现长按效果
                        this.movePlayer(dx, dy);
                    }, 200);
                };

                // 释放按钮时的处理函数
                const handleDpadRelease = () => {
                    clearInterval(this.dpadInterval);
                };

                // 辅助函数，为按钮添加事件监听
                const addListeners = (element, dx, dy) => {
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleDpadPress(dx, dy);
                    });
                    element.addEventListener('mousedown', () => handleDpadPress(dx, dy));
                };

                addListeners(upBtn, 0, -1);
                addListeners(downBtn, 0, 1);
                addListeners(leftBtn, -1, 0);
                addListeners(rightBtn, 1, 0);

                // 监听全局的释放事件
                document.addEventListener('touchend', handleDpadRelease);
                document.addEventListener('mouseup', handleDpadRelease);
            }

            // ==================================================
            //  自定义通知与动画
            // ==================================================

            /**
             * 显示一个短暂的顶部通知 (Toast)
             * @param {string} message - 要显示的消息
             * @param {number} duration - 显示时长 (毫秒)
             * @param {string} type - 通知类型 ('info', 'success', 'error')
             */
            showToast(message, duration = 3000, type = 'info') {
                clearTimeout(this.toastTimeout);
                this.toastElement.classList.remove('show');

                // 使用短暂延时来确保浏览器能重置CSS动画
                setTimeout(() => {
                    this.toastElement.textContent = message;
                    this.toastElement.className = 'toast'; 
                    if (type !== 'info') {
                        this.toastElement.classList.add(type);
                    }
                    this.toastElement.classList.add('show');

                    this.toastTimeout = setTimeout(() => {
                        this.toastElement.classList.remove('show');
                    }, duration);
                }, 100);
            }

            /**
             * 显示一个确认对话框
             * @param {string} message - 确认信息
             * @param {function} onConfirm - 用户点击确认后执行的回调函数
             */
            showConfirm(message, onConfirm) {
                this.confirmMessage.textContent = message;
                this.confirmOverlay.style.display = 'flex';

                const hide = () => {
                    this.confirmOverlay.style.display = 'none';
                    this.confirmYesBtn.onclick = null;
                    this.confirmNoBtn.onclick = null;
                };

                this.confirmYesBtn.onclick = () => {
                    hide();
                    onConfirm();
                };
                this.confirmNoBtn.onclick = hide;
            }

            /**
             * 启动基于 requestAnimationFrame 的动画循环，用于渲染拖尾等效果
             */
            startAnimationLoop() {
                if (this.animationFrameId) return;
                const trailLifetime = 500; // 拖尾效果的持续时间

                const loop = () => {
                    const now = Date.now();
                    
                    // 过滤掉已经过期的拖尾点
                    this.player.trail = this.player.trail.filter(p => now - p.timestamp < trailLifetime);
                    this.ghosts.forEach(g => {
                        g.trail = g.trail.filter(p => now - p.timestamp < trailLifetime);
                    });

                    if (this.state === GAME_STATES.PLAYING) {
                        this.draw(); // 重绘画面
                        this.animationFrameId = requestAnimationFrame(loop);
                    } else {
                        this.stopAnimationLoop();
                    }
                };
                this.animationFrameId = requestAnimationFrame(loop);
            }

            /**
             * 停止动画循环
             */
            stopAnimationLoop() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            // ==================================================
            //  游戏初始化与状态管理
            // ==================================================
            
            /**
             * 根据提供的地图数据开始或重置游戏
             * @param {object} mapData - 包含地图所有信息的对象
             */
            startGame(mapData) {
                this.stopAnimationLoop();
                this.mapData = JSON.parse(JSON.stringify(mapData)); // 深拷贝地图数据以备重置
                this.state = GAME_STATES.PLAYING;

                // 重置历史记录系统
                this.history = [];
                this.checkpoints = [];
                this.currentStep = -1;
                
                // 应用地图尺寸
                this.width = mapData.width;
                this.height = mapData.height;
                this.cellSize = canvas.width / this.width;
                this._renderStaticLayer(); // 渲染静态背景层
                
                // 加载地图结构
                this.hWalls = JSON.parse(JSON.stringify(mapData.hWalls)); // 使用深拷贝
                this.vWalls = JSON.parse(JSON.stringify(mapData.vWalls)); // 使用深拷贝
                this.endPos = mapData.endPos;
                this.items = mapData.items || [];
                this.buttons = mapData.buttons || []; // 加载按钮

                // 初始化所有字母门的当前状态
                this.hWalls.forEach(row => row.forEach(wall => {
                    if (wall.type === WALL_TYPES.LETTER_DOOR) {
                        wall.currentState = wall.initialState || 'closed';
                    }
                }));
                this.vWalls.forEach(row => row.forEach(wall => {
                    if (wall.type === WALL_TYPES.LETTER_DOOR) {
                        wall.currentState = wall.initialState || 'closed';
                    }
                }));
                
                // 初始化玩家状态
                this.player = { x: 1, y: this.height - 2, trail: [], keys: 0 ,steps: 0 };
                if (this.gameMode === 'exploration') {
                    this.player.hp = this.initialHealth;
                } else {
                    this.player.stamina = this.initialStamina;
                    this.loopCount = 0;
                }
                
                // 初始化鬼的状态
                this.ghosts = JSON.parse(JSON.stringify(mapData.initialGhosts));
                this.ghosts.forEach(g => g.trail = []);
                
                // 仅在全新开始或探索模式下重置视野
                if (this.gameMode === 'exploration' || this.loopCount === 0) {
                    this.seenCells = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
                }
                this.updateVisibility();
                
                // 更新UI，隐藏浮窗，并开始游戏循环
                this.updateUIDisplays();
                this.hideAllOverlays();
                this.startAnimationLoop();

                // 记录游戏的初始状态
                this.recordHistory();
            }

            /**
             * 生成一张新的随机地图并开始游戏
             */
            generateNewRandomMap() {
                const size = parseInt(this.mapSizeInput.value);
                if (size < 8 || size > 20) {
                    this.showToast('地图大小必须在 8 到 20 之间。', 3000, 'error');
                    return;
                }
                // 随机地图总是使用默认的生命和体力值
                this.initialHealth = 5;
                this.initialStamina = 100;
                const mapData = this.generateMaze(size, size);
                this.startGame(mapData);
            }
            
            /**
             * 重置当前地图，回到初始状态
             */
            resetCurrentMap() {
                if (!this.mapData) {
                    this.showToast("没有可重置的地图。请先生成一个新地图。", 3000, 'error');
                    return;
                }
                this.startGame(this.mapData);
            }

            // ==================================================
            //  地图生成
            // ==================================================

            /**
             * 使用随机深度优先搜索算法生成迷宫
             * @param {number} width - 地图宽度
             * @param {number} height - 地图高度
             * @returns {object} 生成的地图数据
             */
            generateMaze(width, height) {
                this.width = width;
                this.height = height;
                this.cellSize = canvas.width / this.width;

                // 定义墙体、空地和门的基础对象
                const wall = () => ({ type: WALL_TYPES.SOLID, keys: 0 });
                const empty = () => ({ type: WALL_TYPES.EMPTY, keys: 0 });
                const door = () => ({ type: WALL_TYPES.DOOR, keys: 0 });

                // 1. 初始化，所有地方都是墙
                this.hWalls = Array(height + 1).fill(null).map(() => Array(width).fill(null).map(wall));
                this.vWalls = Array(height).fill(null).map(() => Array(width + 1).fill(null).map(wall));

                // 2. 创建一个3x3的固定起始房间
                const roomY = height - 3;
                for (let y = roomY; y < roomY + 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        if (x < 2) this.vWalls[y][x + 1] = empty();
                        if (y < roomY + 2) this.hWalls[y + 1][x] = empty();
                    }
                }
                this.vWalls[roomY + 1][3] = door(); // 房间出口
                this.hWalls[roomY][1] = door(); // 房间出口
                this.startPos = { x: 1, y: height - 2 };

                // 3. 使用深度优先搜索(DFS)算法生成迷宫路径
                const visited = Array(height).fill(null).map(() => Array(width).fill(false));
                for (let y = roomY; y < roomY + 3; y++) { // 标记起始房间为已访问
                    for (let x = 0; x < 3; x++) {
                        visited[y][x] = true;
                    }
                }
                
                const stack = [];
                let startGenX, startGenY;
                do { // 随机选择一个不在起始房间内的点开始生成
                    startGenX = Math.floor(Math.random() * width);
                    startGenY = Math.floor(Math.random() * height);
                } while (visited[startGenY][startGenX]);

                stack.push({ x: startGenX, y: startGenY });
                visited[startGenY][startGenX] = true;

                while (stack.length > 0) {
                    const current = stack.pop();
                    const neighbors = [];
                    const dirs = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}];
                    for (const dir of dirs) {
                        const nx = current.x + dir.x;
                        const ny = current.y + dir.y;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                            neighbors.push({ x: nx, y: ny, dir: dir });
                        }
                    }

                    if (neighbors.length > 0) {
                        stack.push(current);
                        const { x: nx, y: ny, dir } = neighbors[Math.floor(Math.random() * neighbors.length)];
                        // 打破当前单元格和邻居之间的墙
                        if (dir.x === 1) this.vWalls[current.y][current.x + 1] = empty();
                        else if (dir.x === -1) this.vWalls[current.y][current.x] = empty();
                        else if (dir.y === 1) this.hWalls[current.y + 1][current.x] = empty();
                        else if (dir.y === -1) this.hWalls[current.y][current.x] = empty();
                        visited[ny][nx] = true;
                        stack.push({ x: nx, y: ny });
                    }
                }
                
                // 4. 随机移除一些墙，增加迷宫的连通性
                const wallsToRemove = Math.floor(width * height * 0.08);
                let removedCount = 0;
                let attempts = 0;
                while (removedCount < wallsToRemove && attempts < wallsToRemove * 10) {
                    attempts++;
                    const rx = Math.floor(Math.random() * (width - 1));
                    const ry = Math.floor(Math.random() * (height - 1));

                    if (Math.random() > 0.5) {
                        if (rx < width - 1 && !(ry >= roomY && ry < roomY + 3 && rx + 1 === 3)) {
                            if (this.vWalls[ry][rx + 1].type === WALL_TYPES.SOLID) {
                                this.vWalls[ry][rx + 1] = empty();
                                removedCount++;
                            }
                        }
                    } else {
                        if (ry < height - 1 && !(rx >= 0 && rx < 3 && ry + 1 === roomY)) {
                             if (this.hWalls[ry + 1][rx].type === WALL_TYPES.SOLID) {
                                this.hWalls[ry + 1][rx] = empty();
                                removedCount++;
                            }
                        }
                    }
                }

                // 5. 找到离起点最远的死胡同作为终点
                this.endPos = this.findFarthestEndCell();

                // 6. 随机放置一些门
                const doorProbability = 0.02;
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const isNearEnd = (Math.abs(x - this.endPos.x) <= 1 && y === this.endPos.y) || (x === this.endPos.x && Math.abs(y - this.endPos.y) <= 1);
                        if (y < this.height - 1 && !this.isPosInStartRoom(x, y) && !this.isPosInStartRoom(x, y + 1) && !isNearEnd && Math.random() < doorProbability) this.hWalls[y + 1][x] = door();
                        if (x < width - 1 && !this.isPosInStartRoom(x, y) && !this.isPosInStartRoom(x + 1, y) && !isNearEnd && Math.random() < doorProbability) this.vWalls[y][x + 1] = door();
                    }
                }

                // 7. 在终点处放置一个需要3把钥匙的数字门
                const {x: ex, y: ey} = this.endPos;
                const lockedDoor = { type: WALL_TYPES.LOCKED, keys: 3 };
                if (this.hWalls[ey][ex].type === WALL_TYPES.EMPTY) this.hWalls[ey][ex] = lockedDoor;
                else if (this.hWalls[ey + 1][ex].type === WALL_TYPES.EMPTY) this.hWalls[ey + 1][ex] = lockedDoor;
                else if (this.vWalls[ey][ex].type === WALL_TYPES.EMPTY) this.vWalls[ey][ex] = lockedDoor;
                else if (this.vWalls[ey][ex + 1].type === WALL_TYPES.EMPTY) this.vWalls[ey][ex + 1] = lockedDoor;

                // 8. 随机放置鬼和钥匙
                const occupied = new Set(); // 记录已被占用的格子
                occupied.add(`${this.endPos.x},${this.endPos.y}`);
                for (let y = height - 3; y < height; y++) {
                    for (let x = 0; x < 3; x++) {
                        occupied.add(`${x},${y}`);
                    }
                }

                const initialGhosts = [];
                while (initialGhosts.length < this.ghostCount) {
                    const x = Math.floor(Math.random() * width);
                    const y = Math.floor(Math.random() * height);
                    const posKey = `${x},${y}`;
                    if (!occupied.has(posKey)) {
                        initialGhosts.push({ x, y, id: initialGhosts.length });
                        occupied.add(posKey);
                    }
                }

                this.items = [];
                const keysToPlace = 4;
                const validCells = []; // 所有可放置物品的格子
                const preferredCells = []; // 优先放置物品的格子 (死胡同)
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (!occupied.has(`${x},${y}`)) {
                            validCells.push({x, y});
                            let wallCount = 0;
                            if (this.hWalls[y][x].type > 0) wallCount++;
                            if (this.hWalls[y + 1][x].type > 0) wallCount++;
                            if (this.vWalls[y][x].type > 0) wallCount++;
                            if (this.vWalls[y][x + 1].type > 0) wallCount++;
                            if (wallCount >= 3) {
                                preferredCells.push({x, y});
                            }
                        }
                    }
                }

                for (let i = 0; i < keysToPlace; i++) {
                    let pos = null;
                    if (preferredCells.length > 0) { // 优先从死胡同中选择
                        const index = Math.floor(Math.random() * preferredCells.length);
                        pos = preferredCells.splice(index, 1)[0];
                    } else if (validCells.length > 0) {
                        const index = Math.floor(Math.random() * validCells.length);
                        pos = validCells.splice(index, 1)[0];
                    }
                    if (pos) {
                        this.items.push({ x: pos.x, y: pos.y, type: 'key' });
                        const validIndex = validCells.findIndex(c => c.x === pos.x && c.y === pos.y);
                        if (validIndex > -1) validCells.splice(validIndex, 1);
                    }
                }

                // 9. 返回完整的地图数据
                return {
                    width, height,
                    hWalls: this.hWalls, vWalls: this.vWalls,
                    endPos: this.endPos, initialGhosts: initialGhosts, items: this.items
                };
            }
            
            /**
             * 找到地图边界上离起点最远的死胡同作为终点
             * @returns {object} 终点坐标 {x, y}
             */
            findFarthestEndCell() {
                const distances = this.calculateDistances(this.startPos);
                let maxDist = -1;
                let farthestCell = null;

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        // 只考虑地图边缘的格子
                        if (x === 0 || x === this.width - 1 || y === 0 || y === this.height - 1) {
                            let wallCount = 0;
                            if (this.hWalls[y][x].type > 0) wallCount++;
                            if (this.hWalls[y + 1][x].type > 0) wallCount++;
                            if (this.vWalls[y][x].type > 0) wallCount++;
                            if (this.vWalls[y][x + 1].type > 0) wallCount++;
                            
                            // 必须是死胡同 (三面是墙)
                            if (wallCount >= 3) {
                                if (distances[y][x] > maxDist) {
                                    maxDist = distances[y][x];
                                    farthestCell = { x, y };
                                }
                            }
                        }
                    }
                }
                return farthestCell || { x: this.width - 1, y: 0 }; // 如果没找到，提供一个默认值
            }

            // ==================================================
            //  玩家逻辑
            // ==================================================

            /**
             * 处理键盘按键事件
             * @param {KeyboardEvent} e - 键盘事件对象
             */
            handleKeyPress(e) {
                if (this.state !== GAME_STATES.PLAYING) return;
                this.stopAutoMove();

                let dx = 0, dy = 0;
                switch (e.key) {
                    case 'ArrowUp': case 'w': dy = -1; break;
                    case 'ArrowDown': case 's': dy = 1; break;
                    case 'ArrowLeft': case 'a': dx = -1; break;
                    case 'ArrowRight': case 'd': dx = 1; break;
                    default: return;
                }
                e.preventDefault();
                this.movePlayer(dx, dy);
            }

            /**
             * 移动玩家并处理移动引发的所有游戏逻辑
             * @param {number} dx - X方向的移动 (-1, 0, 1)
             * @param {number} dy - Y方向的移动 (-1, 0, 1)
             */
            movePlayer(dx, dy) {
                if (this.state !== GAME_STATES.PLAYING) return;

                // 首先检查是否按下了按钮
                const button = this.buttons.find(b => 
                    b.x === this.player.x && 
                    b.y === this.player.y && 
                    b.direction.dx === dx && 
                    b.direction.dy === dy
                );
                if (button) {
                    this.pressButton(button.letter);
                    return; // 按下按钮不移动，直接返回
                }

                const playerPrevPos = { x: this.player.x, y: this.player.y };
                const newX = this.player.x + dx;
                const newY = this.player.y + dy;

                // 1. 检查是否越界
                if (newX < 0 || newX >= this.width || newY < 0 || newY >= this.height) return;

                // 2. 检查是否有墙阻挡
                let wall;
                if (dx === 1) wall = this.vWalls[this.player.y][this.player.x + 1];
                if (dx === -1) wall = this.vWalls[this.player.y][this.player.x];
                if (dy === 1) wall = this.hWalls[this.player.y + 1][this.player.x];
                if (dy === -1) wall = this.hWalls[this.player.y][this.player.x];

                if (wall) {
                    if (wall.type === WALL_TYPES.SOLID || wall.type === WALL_TYPES.GLASS) return;
                    if (wall.type === WALL_TYPES.ONE_WAY && (dx !== wall.direction.dx || dy !== wall.direction.dy)) return;
                    if (wall.type === WALL_TYPES.LOCKED && this.player.keys < wall.keys) return;
                    if (wall.type === WALL_TYPES.LETTER_DOOR && wall.currentState === 'closed') return; 
                    if (wall.type === WALL_TYPES.LOCKED && this.player.keys >= wall.keys) {
                        wall.type = WALL_TYPES.EMPTY;
                    }
                }

                // 3. 更新玩家状态
                this.player.trail.unshift({ x: this.player.x, y: this.player.y, timestamp: Date.now() });
                this.player.x = newX;
                this.player.y = newY;
                this.player.steps++;
                if (this.gameMode === 'death-loop') {
                    this.player.stamina--;
                }
                
                // 4. 更新UI和视野
                this.updateUIDisplays();               
                this.updateVisibility();
                this.checkItemPickup();

                // 5. 检查胜利条件
                if (this.endPos && this.player.x === this.endPos.x && this.player.y === this.endPos.y) {
                    this.handleWin();
                    return;
                }

                // 6. 检查死亡条件 (体力耗尽)
                if (this.gameMode === 'death-loop' && this.player.stamina <= 0) {
                    this.handlePlayerDeath('stamina_depleted');
                    return;
                }

                // 7. 检查是否与鬼碰撞
                if (this.checkCollisionWithGhosts()) {
                    this.handlePlayerDeath('ghost');
                    return;
                }

                // 8. 移动鬼
                this.moveGhosts(playerPrevPos);

                // 9. 再次检查鬼移动后是否与玩家碰撞
                if (this.checkCollisionWithGhosts()) {
                    this.handlePlayerDeath('ghost');
                    return;
                }
                
                // 10. 更新警告并记录历史
                this.updateProximityWarning();
                if (!this.animationFrameId) this.draw();
                this.recordHistory();
            }

            /**
             * 按下按钮，切换所有对应字母门的开关状态
             * @param {string} letter - 按下的按钮的字母
             */
            pressButton(letter) {
                let toggled = false;
                const toggleState = (wall) => {
                    if (wall.type === WALL_TYPES.LETTER_DOOR && wall.letter === letter) {
                        wall.currentState = (wall.currentState === 'closed') ? 'open' : 'closed';
                        toggled = true;
                    }
                };

                this.hWalls.forEach(row => row.forEach(toggleState));
                this.vWalls.forEach(row => row.forEach(toggleState));

                if (toggled) {
                    this.showToast(`切换了字母门 '${letter}'`, 1500);
                    this.draw(); // 状态改变，立即重绘
                }
            }

            /**
             * 检查玩家当前位置是否有物品并拾取
             */
            checkItemPickup() {
                const itemIndex = this.items.findIndex(item => item.x === this.player.x && item.y === this.player.y);
                if (itemIndex > -1) {
                    const item = this.items[itemIndex];
                    if (item.type === 'key') {
                        this.player.keys++;
                        this.showToast(`钥匙+1 (现在持有${this.player.keys}个)`, 2000, 'success');
                    }
                    this.items.splice(itemIndex, 1); // 从地图上移除物品
                    this.updateUIDisplays();
                }
            }
            
            /**
             * 将玩家位置重置到出生点
             */
            resetPlayerPos() {
                this.player.x = this.startPos.x;
                this.player.y = this.height - 2;
                this.player.trail = [];
            }
            
            /**
             * 更新所有UI显示，如生命、钥匙、步数等
             */
            updateUIDisplays() {
                if (this.gameMode === 'exploration') {
                    this.healthDisplay.textContent = `生命: ${this.player.hp}`;
                    this.keysDisplay.textContent = `钥匙: ${this.player.keys}`;
                    this.stepsDisplay.textContent = `步数: ${this.player.steps}`;
                } else { // death-loop
                    document.getElementById('loop-count-display').textContent = `循环次数: ${this.loopCount}`;
                    document.getElementById('player-keys-display-death-loop').textContent = `钥匙: ${this.player.keys}`;
                    document.getElementById('player-stamina-display').textContent = `剩余体力: ${this.player.stamina}`;
                }
                this.updateProximityWarning();
            }

            /**
             * 更新周围鬼数量的警告显示和背景效果
             */
            updateProximityWarning() {
                if (this.gameMode === 'death-loop') { // 死亡循环模式无此功能
                    document.body.classList.remove('danger-bg');
                    this.ghostProximityDisplay.classList.remove('warning');
                    return;
                }

                let totalNearbyGhosts = 0;
                let invisibleNearbyGhosts = 0;

                for (const ghost of this.ghosts) {
                    const isNearby = Math.abs(ghost.x - this.player.x) <= 1 && Math.abs(ghost.y - this.player.y) <= 1;
                    if (isNearby) {
                        totalNearbyGhosts++;
                        const isVisible = this.seenCells[ghost.y][ghost.x] || this.debugVision;
                        if (!isVisible) {
                            invisibleNearbyGhosts++;
                        }
                    }
                }

                this.ghostProximityDisplay.textContent = `周围鬼数: ${totalNearbyGhosts}`;

                // 如果附近有看不见的鬼，则触发警告效果
                if (invisibleNearbyGhosts > 0) {
                    document.body.classList.add('danger-bg');
                    this.ghostProximityDisplay.classList.add('warning');
                } else {
                    document.body.classList.remove('danger-bg');
                    this.ghostProximityDisplay.classList.remove('warning');
                }
            }

            // ==================================================
            //  鬼逻辑
            // ==================================================
            
            /**
             * 检查鬼是否能沿直线看到玩家（无障碍）
             * @param {object} ghost - 鬼对象
             * @param {object} playerPos - 玩家坐标 {x, y}
             * @returns {boolean} 是否能看到
             */
            canGhostSeePlayer(ghost, playerPos) {
                if (!playerPos || ghost.x !== playerPos.x && ghost.y !== playerPos.y) return false;
                
                if (ghost.x === playerPos.x) { // 垂直方向
                    const startY = Math.min(ghost.y, playerPos.y);
                    const endY = Math.max(ghost.y, playerPos.y);
                    for (let y = startY; y < endY; y++) {
                        const wall = this.hWalls[y + 1][ghost.x];
                        if ( (wall.type > 0 && wall.type !== WALL_TYPES.GLASS) &&
                             !(wall.type === WALL_TYPES.LETTER_DOOR && wall.currentState === 'open') ) {
                            return false;
                        }
                    }
                } else { // 水平方向
                    const startX = Math.min(ghost.x, playerPos.x);
                    const endX = Math.max(ghost.x, playerPos.x);
                    for (let x = startX; x < endX; x++) {
                        const wall = this.vWalls[ghost.y][x + 1];
                        if ( (wall.type > 0 && wall.type !== WALL_TYPES.GLASS) &&
                             !(wall.type === WALL_TYPES.LETTER_DOOR && wall.currentState === 'open') ) {
                            return false;
                        }
                    } 
                }
                return true;
            }

            /**
             * 移动所有鬼的逻辑
             * @param {object} playerPrevPos - 玩家移动前的位置
             */
            moveGhosts(playerPrevPos) {
                let moveIntents = [];

                // 阶段一：收集所有鬼的移动意图
                for (const ghost of this.ghosts) {
                    const sawBefore = this.canGhostSeePlayer(ghost, playerPrevPos);
                    const seesAfter = this.canGhostSeePlayer(ghost, this.player);

                    let target = null;
                    if (!sawBefore && seesAfter) target = this.player; // 玩家进入视野
                    if (sawBefore && !seesAfter) target = playerPrevPos; // 玩家离开视野
                    if (sawBefore && seesAfter) target = this.player; // 玩家在视野内移动
                    
                    if (target) {
                        const path = this.findShortestPath(ghost, target);
                        if (path && path.length > 1) {
                            moveIntents.push({ ghost: ghost, nextStep: path[1] });
                        }
                    }
                }

                if (moveIntents.length === 0) return;

                // 阶段二：解决移动冲突并执行移动
                let maxIterations = this.ghosts.length + 1; 
                let madeProgress = true;

                while (madeProgress && moveIntents.length > 0 && maxIterations > 0) {
                    madeProgress = false;
                    maxIterations--;

                    const occupiedCells = new Set(this.ghosts.map(g => `${g.x},${g.y}`));
                    let possibleMoves = [];
                    let remainingIntents = [];

                    // 筛选出目标格子当前为空的移动
                    for (const intent of moveIntents) {
                        const targetKey = `${intent.nextStep.x},${intent.nextStep.y}`;
                        if (!occupiedCells.has(targetKey)) {
                            possibleMoves.push(intent);
                        } else {
                            remainingIntents.push(intent);
                        }
                    }

                    // 解决多个鬼抢同一个格子的冲突
                    const finalMovesThisPass = [];
                    const claimedTargets = new Set();
                    for (const intent of possibleMoves) {
                        const targetKey = `${intent.nextStep.x},${intent.nextStep.y}`;
                        if (!claimedTargets.has(targetKey)) {
                            finalMovesThisPass.push(intent);
                            claimedTargets.add(targetKey);
                        } else {
                            remainingIntents.push(intent);
                        }
                    }

                    // 执行本轮确定的移动
                    if (finalMovesThisPass.length > 0) {
                        for (const { ghost, nextStep } of finalMovesThisPass) {
                            ghost.trail.unshift({ x: ghost.x, y: ghost.y, timestamp: Date.now() });
                            ghost.x = nextStep.x;
                            ghost.y = nextStep.y;
                        }
                        madeProgress = true;
                    }
                    
                    moveIntents = remainingIntents; // 继续处理未解决的移动意图
                }
            }
            
            /**
             * 检查指定坐标是否被其他鬼占据
             * @param {number} x - X坐标
             * @param {number} y - Y坐标
             * @param {number} selfId - 要排除的鬼的ID
             * @returns {boolean} 是否被占据
             */
            isCellOccupiedByGhost(x, y, selfId = -1) {
                return this.ghosts.some(g => g.id !== selfId && g.x === x && g.y === y);
            }

            // ==================================================
            //  游戏结束与浮窗
            // ==================================================
            
            /**
             * 检查玩家是否与任何一个鬼在同一个格子上
             * @returns {boolean} 是否发生碰撞
             */
            checkCollisionWithGhosts() {
                return this.ghosts.some(g => g.x === this.player.x && g.y === this.player.y);
            }

            /**
             * 处理玩家死亡事件
             * @param {string} reason - 死亡原因 ('ghost', 'stamina_depleted')
             */
            handlePlayerDeath(reason = 'ghost') {
                this.stopAutoMove();
                this.stopAnimationLoop();
                this.state = GAME_STATES.DEAD;
                
                if (this.gameMode === 'exploration') {
                    this.player.hp--;
                    this.updateUIDisplays();
                    this.draw();
                    if (this.player.hp > 0) { // 还有生命值，可以复活
                        document.getElementById('death-message').textContent = `你死了 (剩余血量 ${this.player.hp})`;
                        document.getElementById('revive-btn').textContent = '复活';
                        document.getElementById('death-overlay').style.display = 'flex';
                    } else { // 生命值耗尽，游戏结束
                        document.getElementById('game-over-overlay').style.display = 'flex';
                    }
                } else { // 死亡循环模式
                    this.draw();
                    const message = reason === 'stamina_depleted' ? '体力耗尽，你死了' : '你死了';
                    document.getElementById('death-message').textContent = message;
                    document.getElementById('revive-btn').textContent = '复活';
                    document.getElementById('death-overlay').style.display = 'flex';
                }
            }
            
            /**
             * 处理玩家复活逻辑
             */
            revivePlayer() {
                if (this.gameMode === 'exploration') {
                    this.resetPlayerPos();
                    this.state = GAME_STATES.PLAYING;
                    this.hideAllOverlays();
                    this.updateVisibility();
                    this.updateProximityWarning();
                    this.startAnimationLoop();
                    this.recordHistory(true); // 记录一个复活点
                } else { // 死亡循环模式
                    this.loopCount++;
                    this.state = GAME_STATES.PLAYING;
                    this.hideAllOverlays();

                    // 重置玩家和地图状态，但保留已探索的视野
                    this.resetPlayerPos();
                    this.player.keys = 0;
                    this.player.steps = 0;
                    this.player.stamina = this.initialStamina;
                    
                    // 从原始地图数据中重置物品和鬼
                    this.items = JSON.parse(JSON.stringify(this.mapData.items || []));
                    this.ghosts = JSON.parse(JSON.stringify(this.mapData.initialGhosts));
                    this.hWalls = JSON.parse(JSON.stringify(this.mapData.hWalls)); 
                    this.vWalls = JSON.parse(JSON.stringify(this.mapData.vWalls));
                    this.ghosts.forEach(g => g.trail = []); // 初始化拖尾数组

                    // 重置所有字母门的当前状态
                    this.hWalls.forEach(row => row.forEach(wall => {
                        if (wall.type === WALL_TYPES.LETTER_DOOR) {
                            wall.currentState = wall.initialState || 'closed';
                        }
                    }));
                    this.vWalls.forEach(row => row.forEach(wall => {
                        if (wall.type === WALL_TYPES.LETTER_DOOR) {
                            wall.currentState = wall.initialState || 'closed';
                        }
                    }));

                    this.updateVisibility();
                    this.updateUIDisplays();
                    this.startAnimationLoop();
                    this.recordHistory(true); // 记录一个复活点
                }
            }

            /**
             * 处理游戏胜利逻辑
             */
            handleWin() {
                this.stopAutoMove();
                this.stopAnimationLoop();
                this.state = GAME_STATES.WON;

                const winStats = document.getElementById('win-stats');
                if (this.gameMode === 'exploration') {
                    winStats.textContent = `你以 ${this.player.hp} 点剩余生命和 ${this.player.steps} 步的成绩通关！`;
                } else { // death-loop
                    winStats.textContent = `你以 ${this.loopCount} 次循环和 ${this.player.stamina} 点剩余体力的成绩通关！`;
                }

                document.getElementById('win-overlay').style.display = 'flex';
            }
            
            /**
             * 隐藏所有游戏状态浮窗
             */
            hideAllOverlays() {
                document.getElementById('death-overlay').style.display = 'none';
                document.getElementById('game-over-overlay').style.display = 'none';
                document.getElementById('win-overlay').style.display = 'none';
            }

            // ==================================================
            //  视野系统
            // ==================================================

            /**
             * 根据玩家当前位置更新可见的单元格
             */
            updateVisibility() {
                // 起始房间永久可见
                const roomY = this.height - 3;
                for (let y = roomY; y < roomY + 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        this.seenCells[y][x] = true;
                    }
                }

                const { x, y } = this.player;
                this.seenCells[y][x] = true; // 玩家当前格子可见

                // 沿四个方向进行“射线投射”，直到遇到非玻璃墙
                for (let i = x + 1; i < this.width; i++) {
                    const wall = this.vWalls[y][i];
                    if (wall.type > 0 && wall.type !== WALL_TYPES.GLASS) break;
                    this.seenCells[y][i] = true;
                }
                for (let i = x - 1; i >= 0; i--) {
                    const wall = this.vWalls[y][i + 1];
                    if (wall.type > 0 && wall.type !== WALL_TYPES.GLASS) break;
                    this.seenCells[y][i] = true;
                }
                for (let i = y + 1; i < this.height; i++) {
                    const wall = this.hWalls[i][x];
                    if (wall.type > 0 && wall.type !== WALL_TYPES.GLASS) break;
                    this.seenCells[i][x] = true;
                }
                for (let i = y - 1; i >= 0; i--) {
                    const wall = this.hWalls[i + 1][x];
                    if (wall.type > 0 && wall.type !== WALL_TYPES.GLASS) break;
                    this.seenCells[i][x] = true;
                }
            }

            // ==================================================
            //  渲染
            // ==================================================

            /**
             * [私有] 渲染静态背景层（地面、网格线）到离屏Canvas
             */
            _renderStaticLayer() {
                this.staticLayerCanvas.width = canvas.width;
                this.staticLayerCanvas.height = canvas.height;
                const ctx = this.staticLayerCtx;
                const cs = this.cellSize;

                // 绘制地面
                ctx.fillStyle = this.colors.ground;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 绘制网格线
                ctx.strokeStyle = this.colors.gridLine;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i <= this.width; i++) {
                    const x = Math.round(i * cs) + 0.5;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.height * cs);
                }
                for (let i = 0; i <= this.height; i++) {
                    const y = Math.round(i * cs) + 0.5;
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.width * cs, y);
                }
                ctx.stroke();
            }

            /**
             * 主渲染函数，负责在Canvas上绘制整个游戏画面
             */
            draw() {
                if (this.state === GAME_STATES.MENU) return;
                if (this.editor.active) {
                    this.drawEditor(); // 如果在编辑器模式，则调用编辑器渲染函数
                    return;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const cs = this.cellSize;
                const now = Date.now();
                const trailLifetime = 500;
                const initialAlpha = 0.3;

                // 渲染层级 1: 静态背景 (从离屏Canvas绘制)
                ctx.drawImage(this.staticLayerCanvas, 0, 0);
                
                // 渲染层级 2: 拖尾效果
                this.player.trail.forEach(p => {
                    if (this.seenCells[p.y][p.x] || this.debugVision) {
                        const age = now - p.timestamp;
                        const alpha = initialAlpha * (1 - age / trailLifetime);
                        this.drawCircle(p.x, p.y, this.colors.player, alpha);
                    }
                });
                this.ghosts.forEach(ghost => {
                    ghost.trail.forEach(p => {
                        if (this.seenCells[p.y][p.x] || this.debugVision) {
                            const age = now - p.timestamp;
                            const alpha = initialAlpha * (1 - age / trailLifetime);
                            this.drawCircle(p.x, p.y, this.colors.ghost, alpha);
                        }
                    });
                });

                // 渲染层级 3: 未探索区域的战争迷雾
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (!this.seenCells[y][x] && !this.debugVision) {
                            ctx.fillStyle = this.colors.unexplored;
                            ctx.fillRect(x * cs, y * cs, cs, cs);
                        }
                    }
                }

                // 渲染层级 4: 墙体
                ctx.beginPath();
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.seenCells[y][x] || this.debugVision) {
                            if (this.hWalls[y][x].type > 0) this.drawWallOrDoor(x * cs, y * cs, (x + 1) * cs, y * cs, this.hWalls[y][x]);
                            if (this.hWalls[y + 1][x].type > 0) this.drawWallOrDoor(x * cs, (y + 1) * cs, (x + 1) * cs, (y + 1) * cs, this.hWalls[y + 1][x]);
                            if (this.vWalls[y][x].type > 0) this.drawWallOrDoor(x * cs, y * cs, x * cs, (y + 1) * cs, this.vWalls[y][x]);
                            if (this.vWalls[y][x + 1].type > 0) this.drawWallOrDoor((x + 1) * cs, y * cs, (x + 1) * cs, (y + 1) * cs, this.vWalls[y][x + 1]);
                        }
                    }
                }
                ctx.stroke();

                // 渲染层级 5: 终点
                if (this.endPos && (this.seenCells[this.endPos.y][this.endPos.x] || this.debugVision)) {
                    this.drawCircle(this.endPos.x, this.endPos.y, this.colors.endPoint);
                }

                // 渲染层级 6: 鬼和玩家
                this.ghosts.forEach(ghost => {
                    if (this.seenCells[ghost.y][ghost.x] || this.debugVision) {
                        this.drawCircle(ghost.x, ghost.y, this.colors.ghost);
                    }
                });
                this.drawCircle(this.player.x, this.player.y, this.colors.player);
                
                // 渲染层级 7: 物品
                this.items.forEach(item => {
                    if (this.seenCells[item.y][item.x] || this.debugVision) {
                        this.drawItem(item);
                    }
                });

                // 渲染层级 8: 按钮
                this.buttons.forEach(button => {
                    if (this.seenCells[button.y][button.x] || this.debugVision) {
                        this.drawButton(button);
                    }
                });

                // 渲染层级 9: 墙体上的覆盖物 (如数字门的数字)
                this.drawWallOverlays(true);
            }

            /**
             * 绘制单面墙或门
             * @param {number} x1 - 起点X
             * @param {number} y1 - 起点Y
             * @param {number} x2 - 终点X
             * @param {number} y2 - 终点Y
             * @param {object} wallObject - 墙体数据对象
             * @param {boolean} isHighlight - 是否高亮显示
             */
            drawWallOrDoor(x1, y1, x2, y2, wallObject, isHighlight = false) {
                const type = wallObject.type;
                const cs = this.cellSize;

                if (isHighlight) {
                    ctx.strokeStyle = this.colors.hoverHighlight;
                    ctx.lineWidth = Math.max(3, cs / 8);
                } else {
                    ctx.strokeStyle = this.colors.wall;
                    if ([WALL_TYPES.SOLID, WALL_TYPES.DOOR, WALL_TYPES.GLASS].includes(type)) {
                        ctx.lineWidth = Math.max(2, cs / 10);
                    } else if ([WALL_TYPES.LOCKED, WALL_TYPES.ONE_WAY].includes(type)) {
                        ctx.lineWidth = Math.max(3, cs / 12); 
                    }
                }
                
                if (type === WALL_TYPES.SOLID) {
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                } else if (type === WALL_TYPES.GLASS) {
                    const isHorizontal = y1 === y2;
                    const lineLength = cs * 0.2;
                    const offset = lineLength / 2;
                    const points = [
                        { x: x1 * 5/6 + x2 * 1/6, y: y1 * 5/6 + y2 * 1/6 },
                        { x: (x1 + x2) / 2, y: (y1 + y2) / 2 },
                        { x: x1 * 1/6 + x2 * 5/6, y: y1 * 1/6 + y2 * 5/6 }
                    ];
                    for (const p of points) {
                        if (isHorizontal) {
                            ctx.moveTo(p.x - offset, p.y + offset);
                            ctx.lineTo(p.x + offset, p.y - offset);
                        } else {
                            ctx.moveTo(p.x - offset, p.y + offset);
                            ctx.lineTo(p.x + offset, p.y - offset);
                        }
                    }
                } else if (type === WALL_TYPES.LOCKED || type === WALL_TYPES.ONE_WAY || type === WALL_TYPES.LETTER_DOOR) {
                    // 根据当前是游戏还是编辑器，来决定字母门是否渲染为开启状态
                    let isLetterDoorOpen = false;
                    if (type === WALL_TYPES.LETTER_DOOR) {
                        // 将所有非编辑器状态（playing, dead, won）都视为游戏内状态
                        if (this.state === GAME_STATES.EDITOR) {
                            // 在编辑器中，使用初始状态
                            isLetterDoorOpen = wallObject.initialState === 'open';
                        } else {
                            // 在所有其他游戏相关状态中，使用当前状态
                            isLetterDoorOpen = wallObject.currentState === 'open';
                        }
                    }

                    // 如果判定为开启，则不绘制门框
                    if (isLetterDoorOpen) {
                        return;
                    }

                    const isHorizontal = y1 === y2;
                    const lockWidth = cs * 0.2;
                    if (isHorizontal) {
                        ctx.rect(x1, y1 - lockWidth / 2, cs, lockWidth);
                    } else {
                        ctx.rect(x1 - lockWidth / 2, y1, lockWidth, cs);
                    }
                } else if (type === WALL_TYPES.DOOR) {
                    const isHorizontal = y1 === y2;
                    const length = isHorizontal ? x2 - x1 : y2 - y1;
                    const gap = length / 3;
                    if (isHorizontal) {
                        ctx.moveTo(x1, y1); ctx.lineTo(x1 + gap, y1);
                        ctx.moveTo(x2 - gap, y2); ctx.lineTo(x2, y2);
                    } else {
                        ctx.moveTo(x1, y1); ctx.lineTo(x1, y1 + gap);
                        ctx.moveTo(x2, y2 - gap); ctx.lineTo(x2, y2);
                    }
                }
            }

            /**
             * 在墙体中心绘制一个表示方向的箭头
             * @param {number} x1 - 墙体起点X
             * @param {number} y1 - 墙体起点Y
             * @param {number} x2 - 墙体终点X
             * @param {number} y2 - 墙体终点Y
             * @param {object} direction - 方向对象 {dx, dy}
             * @param {string} color - 箭头颜色
             * @param {boolean} withStroke - 是否带描边
             */
            drawArrow(x1, y1, x2, y2, direction, color, withStroke) {
                const centerX = (x1 + x2) / 2;
                const centerY = (y1 + y2) / 2;
                const cs = this.cellSize;
                const fontSize = cs * 0.6; 

                ctx.save(); // 保存画布状态
                ctx.translate(centerX, centerY); // 移动原点到墙中心

                // 根据方向旋转画布
                if (direction.dx === 1) { ctx.rotate(0); } 
                else if (direction.dx === -1) { ctx.rotate(Math.PI); } 
                else if (direction.dy === 1) { ctx.rotate(Math.PI / 2); } 
                else if (direction.dy === -1) { ctx.rotate(-Math.PI / 2); }

                ctx.scale(0.8, 1.0); // 稍微压扁箭头

                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                if (withStroke) {
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText('>', 0, 0);
                }
                ctx.fillStyle = color;
                ctx.fillText('>', 0, 0);

                ctx.restore(); // 恢复画布状态
            }

            /**
             * 绘制所有墙体上的覆盖物，如数字门的数字和单向门的箭头
             * @param {boolean} inGame - 是否在游戏模式下调用
             */
            drawWallOverlays(inGame = false) {
                const cs = this.cellSize;
                
                const drawNumber = (x1, y1, x2, y2, number) => {
                    const centerX = (x1 + x2) / 2;
                    const centerY = (y1 + y2) / 2;
                    const fontSize = this.cellSize * 0.4;
                    const text = number.toString();
                    ctx.font = `bold ${fontSize}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(text, centerX, centerY);
                    ctx.fillStyle = this.colors.key;
                    ctx.fillText(text, centerX, centerY);
                };

                // 遍历水平墙
                for (let y = 1; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const wall = this.hWalls[y][x];
                        const isVisible = !inGame || this.debugVision || this.seenCells[y - 1][x] || this.seenCells[y][x];
                        if (isVisible) {
                            if (wall.type === WALL_TYPES.LOCKED) {
                                drawNumber(x * cs, y * cs, (x + 1) * cs, y * cs, wall.keys);
                            } else if (wall.type === WALL_TYPES.LETTER_DOOR) {
                                drawNumber(x * cs, y * cs, (x + 1) * cs, y * cs, wall.letter);
                            } else if (wall.type === WALL_TYPES.ONE_WAY && wall.direction) {
                                this.drawArrow(x * cs, y * cs, (x + 1) * cs, y * cs, wall.direction, this.colors.key, true);
                            }
                        }
                    }
                }

                // 遍历垂直墙
                for (let y = 0; y < this.height; y++) {
                    for (let x = 1; x < this.width; x++) {
                        const wall = this.vWalls[y][x];
                        const isVisible = !inGame || this.debugVision || this.seenCells[y][x - 1] || this.seenCells[y][x];
                        if (isVisible) {
                            if (wall.type === WALL_TYPES.LOCKED) {
                                drawNumber(x * cs, y * cs, x * cs, (y + 1) * cs, wall.keys);
                            } else if (wall.type === WALL_TYPES.LETTER_DOOR) {
                                drawNumber(x * cs, y * cs, x * cs, (y + 1) * cs, wall.letter);
                            } else if (wall.type === WALL_TYPES.ONE_WAY && wall.direction) {
                                this.drawArrow(x * cs, y * cs, x * cs, (y + 1) * cs, wall.direction, this.colors.key, true);
                            }
                        }
                    }
                }
            }

            /**
             * 在指定格子绘制一个圆形，用于玩家、鬼和终点
             * @param {number} x - 格子X坐标
             * @param {number} y - 格子Y坐标
             * @param {string} color - 颜色
             * @param {number} alpha - 透明度
             */
            drawCircle(x, y, color, alpha = 1.0) {
                if (alpha <= 0) return;
                const cs = this.cellSize;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x * cs + cs / 2, y * cs + cs / 2, cs * 0.35, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            /**
             * 绘制物品，如钥匙
             * @param {object} item - 物品对象
             */
            drawItem(item) {
                if (item.type === 'key') {
                    const cs = this.cellSize;
                    const centerX = item.x * cs + cs / 2;
                    const centerY = item.y * cs + cs / 2;
                    const size = cs * 0.3;
                    ctx.fillStyle = this.colors.key;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - size);
                    ctx.lineTo(centerX + size, centerY);
                    ctx.lineTo(centerX, centerY + size);
                    ctx.lineTo(centerX - size, centerY);
                    ctx.closePath();
                    ctx.fill();
                }
            }

            /**
             * 绘制一个按钮
             * @param {object} button - 按钮对象
             * @param {boolean} isHighlight - 是否为高亮预览模式
             */
            drawButton(button, isHighlight = false) {
                const cs = this.cellSize;
                const centerX = button.x * cs + cs / 2;
                const centerY = button.y * cs + cs / 2;
                
                const buttonLength = cs * 0.5;
                const buttonWidth = cs * 0.2;

                let p1, p2, p3, p4;
                let letterCenterX, letterCenterY;

                // ... (坐标计算的 switch 语句保持不变) ...
                switch (true) {
                    case button.direction.dy === -1: // 依附在上方墙体
                        p1 = { x: centerX - buttonLength / 2, y: button.y * cs };
                        p2 = { x: centerX + buttonLength / 2, y: button.y * cs };
                        p3 = { x: centerX + buttonLength / 2, y: button.y * cs + buttonWidth };
                        p4 = { x: centerX - buttonLength / 2, y: button.y * cs + buttonWidth };
                        letterCenterX = centerX; letterCenterY = p1.y + buttonWidth / 2;
                        break;
                    case button.direction.dy === 1: // 依附在下方墙体
                        p1 = { x: centerX - buttonLength / 2, y: (button.y + 1) * cs - buttonWidth };
                        p2 = { x: centerX + buttonLength / 2, y: (button.y + 1) * cs - buttonWidth };
                        p3 = { x: centerX + buttonLength / 2, y: (button.y + 1) * cs };
                        p4 = { x: centerX - buttonLength / 2, y: (button.y + 1) * cs };
                        letterCenterX = centerX; letterCenterY = p1.y + buttonWidth / 2;
                        break;
                    case button.direction.dx === -1: // 依附在左方墙体
                        p1 = { x: button.x * cs, y: centerY - buttonLength / 2 };
                        p2 = { x: button.x * cs + buttonWidth, y: centerY - buttonLength / 2 };
                        p3 = { x: button.x * cs + buttonWidth, y: centerY + buttonLength / 2 };
                        p4 = { x: button.x * cs, y: centerY + buttonLength / 2 };
                        letterCenterX = p1.x + buttonWidth / 2; letterCenterY = centerY;
                        break;
                    case button.direction.dx === 1: // 依附在右方墙体
                        p1 = { x: (button.x + 1) * cs - buttonWidth, y: centerY - buttonLength / 2 };
                        p2 = { x: (button.x + 1) * cs, y: centerY - buttonLength / 2 };
                        p3 = { x: (button.x + 1) * cs, y: centerY + buttonLength / 2 };
                        p4 = { x: (button.x + 1) * cs - buttonWidth, y: centerY + buttonLength / 2 };
                        letterCenterX = p1.x + buttonWidth / 2; letterCenterY = centerY;
                        break;
                }

                // 1. 移除填充色绘制

                // 2. 绘制边框
                ctx.strokeStyle = isHighlight ? this.colors.hoverHighlight : this.colors.wall;
                ctx.lineWidth = isHighlight ? Math.max(3, cs / 8) : Math.max(2, cs / 10);
                ctx.beginPath();
                // 确保每个方向都绘制三条线段
                switch (true) {
                    case button.direction.dy === -1: // 顶墙 -> 绘制 左,下,右 三边
                        ctx.moveTo(p1.x, p1.y); // 从 top-left 开始
                        ctx.lineTo(p4.x, p4.y); // 画 左边
                        ctx.lineTo(p3.x, p3.y); // 画 底边
                        ctx.lineTo(p2.x, p2.y); // 画 右边
                        break;
                    case button.direction.dy === 1: // 底墙 -> 绘制 左,上,右 三边
                        ctx.moveTo(p4.x, p4.y); // 从 bottom-left 开始
                        ctx.lineTo(p1.x, p1.y); // 画 左边
                        ctx.lineTo(p2.x, p2.y); // 画 顶边
                        ctx.lineTo(p3.x, p3.y); // 画 右边
                        break;
                    case button.direction.dx === -1: // 左墙 -> 绘制 上,右,下 三边
                        ctx.moveTo(p1.x, p1.y); // 从 top-left 开始
                        ctx.lineTo(p2.x, p2.y); // 画 顶边
                        ctx.lineTo(p3.x, p3.y); // 画 右边
                        ctx.lineTo(p4.x, p4.y); // 画 底边
                        break;
                    case button.direction.dx === 1: // 右墙 -> 绘制 上,左,下 三边
                        ctx.moveTo(p2.x, p2.y); // 从 top-right 开始
                        ctx.lineTo(p1.x, p1.y); // 画 顶边
                        ctx.lineTo(p4.x, p4.y); // 画 左边
                        ctx.lineTo(p3.x, p3.y); // 画 底边
                        break;
                }
                ctx.stroke();

                // 3. 绘制字母 (仅在非高亮模式下，且按钮有字母时)
                if (!isHighlight && button.letter) {
                    const fontSize = this.cellSize * 0.4; // 与字母门统一大小
                    ctx.font = `bold ${fontSize}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 3;
                    ctx.strokeText(button.letter, letterCenterX, letterCenterY);
                    ctx.fillStyle = this.colors.key;
                    ctx.fillText(button.letter, letterCenterX, letterCenterY);
                }
            }

            // ==================================================
            //  编辑器逻辑
            // ==================================================
            
            /**
             * 进入地图编辑器模式
             */
            enterEditorMode() {
                this.stopAnimationLoop();
                if (!this.mapData) { // 如果没有现有地图，则创建一个空白地图
                    this.width = 10;
                    this.height = 10;
                    this.createBlankEditorMap();
                    this.mapData = {
                        width: this.width, height: this.height,
                        hWalls: JSON.parse(JSON.stringify(this.hWalls)),
                        vWalls: JSON.parse(JSON.stringify(this.vWalls)),
                        endPos: null,
                        initialGhosts: [],
                        items: []
                    };
                }

                this.state = GAME_STATES.EDITOR;
                this.editor.active = true;
                this.setEditorTool(EDITOR_TOOLS.WALL);
                
                // 切换UI面板
                document.getElementById('game-controls').style.display = 'none';
                document.getElementById('editor-controls').style.display = 'block';
                
                // 从mapData加载数据到编辑器
                this.width = this.mapData.width;
                this.height = this.mapData.height;
                this.editorMapSizeInput.value = this.width;
                this.cellSize = canvas.width / this.width;
                this.hWalls = JSON.parse(JSON.stringify(this.mapData.hWalls));
                this.vWalls = JSON.parse(JSON.stringify(this.mapData.vWalls));
                this.endPos = this.mapData.endPos ? {...this.mapData.endPos} : null;
                this.ghosts = JSON.parse(JSON.stringify(this.mapData.initialGhosts || []));
                this.items = JSON.parse(JSON.stringify(this.mapData.items || []));
                
                this._renderStaticLayer(); // 为编辑器渲染静态背景
                this.drawEditor();
                this.updateDpadVisibility();
            }
            
            /**
             * 创建一个带外墙和起始房间的空白地图
             */
            createBlankEditorMap() {
                this.cellSize = canvas.width / this.width;
                
                const wall = () => ({ type: WALL_TYPES.SOLID, keys: 0 });
                const empty = () => ({ type: WALL_TYPES.EMPTY, keys: 0 });
                const door = () => ({ type: WALL_TYPES.DOOR, keys: 0 });

                // 初始化空地
                this.hWalls = Array(this.height + 1).fill(null).map(() => Array(this.width).fill(null).map(empty));
                this.vWalls = Array(this.height).fill(null).map(() => Array(this.width + 1).fill(null).map(empty));
                
                // 创建外墙
                for (let x = 0; x < this.width; x++) {
                    this.hWalls[0][x] = wall();
                    this.hWalls[this.height][x] = wall();
                }
                for (let y = 0; y < this.height; y++) {
                    this.vWalls[y][0] = wall();
                    this.vWalls[y][this.width] = wall();
                }
                
                // 创建固定的起始房间
                const roomY = this.height - 3;
                for (let x = 0; x < 3; x++) this.hWalls[roomY + 3][x] = wall();
                for (let y = roomY; y < roomY + 3; y++) this.vWalls[y][0] = wall();
                this.hWalls[roomY][0] = wall(); this.hWalls[roomY][2] = wall();
                this.vWalls[roomY][3] = wall(); this.vWalls[roomY+2][3] = wall();
                this.hWalls[roomY][1] = door();
                this.vWalls[roomY+1][3] = door();
                
                // 重置实体
                this.startPos = { x: 1, y: this.height - 2 };
                this.endPos = null;
                this.ghosts = [];
                this.items = [];
            }

            /**
             * 在编辑器中调整地图大小并清空地图
             */
            resizeAndClearEditor() {
                const size = parseInt(this.editorMapSizeInput.value);
                if (size < 8 || size > 20) {
                    this.showToast('地图大小必须在 8 到 20 之间。', 3000, 'error');
                    this.editorMapSizeInput.value = this.width;
                    return;
                }
                this.width = size;
                this.height = size;
                this._renderStaticLayer(); // 尺寸变化，重新渲染静态层
                this.createBlankEditorMap();
                this.drawEditor();
            }
            
            /**
             * 退出编辑器，并使用当前编辑的地图开始游戏
             */
            playEditedMap() {
                this.editor.active = false;
                document.getElementById('game-controls').style.display = 'block';
                document.getElementById('editor-controls').style.display = 'none';
                
                // 从编辑器UI获取初始生命/体力值
                this.initialHealth = parseInt(document.getElementById('editor-initial-health').value) || 5;
                this.initialStamina = parseInt(document.getElementById('editor-initial-stamina').value) || 100;

                // 组装地图数据
                const editedMapData = {
                    width: this.width, height: this.height,
                    hWalls: this.hWalls, vWalls: this.vWalls,
                    endPos: this.endPos,
                    initialGhosts: this.ghosts.map((g, i) => ({x: g.x, y: g.y, id: i})),
                    items: this.items,
                    buttons: this.buttons
                };
                
                this.startGame(editedMapData);
                // 在地址栏写入分享码
                const code = this.generateShareCode(mapData);
                this.updateURLWithShareCode(code);

                this.updateDpadVisibility(); 
            }
            
            /**
            * 更新地址栏 URL 并写入分享码 (?map=xxxx)
            * 不会刷新页面，不会触发重新加载。
            */
            updateURLWithShareCode(code) {
                const newURL = `${window.location.pathname}?map=${encodeURIComponent(code)}`;
                window.history.replaceState({}, "", newURL);
            }

            /**
             * 清空编辑器中的所有内容
             */
            clearEditorMap() {
                this.showConfirm('你确定要清空所有墙壁、实体和物品吗？', () => {
                    this.createBlankEditorMap();
                    this.drawEditor();
                });
            }
            
            /**
             * 设置当前使用的编辑器工具
             * @param {string} tool - 工具名称
             */
            setEditorTool(tool) {
                this.editor.tool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.id === `tool-${tool}`);
                });
                this.editor.hoveredWall = null;
                this.drawEditor();
            }
            
            /**
             * 渲染编辑器界面
             */
            drawEditor() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const cs = this.cellSize;

                // 绘制静态背景和网格
                ctx.drawImage(this.staticLayerCanvas, 0, 0);
                
                // 绘制起始房间高亮
                ctx.fillStyle = this.colors.startRoomHighlight;
                ctx.fillRect(0, (this.height - 3) * cs, 3 * cs, 3 * cs);
                
                // 绘制所有墙体
                ctx.beginPath();
                for (let y = 0; y <= this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.hWalls[y][x].type > 0) {
                            this.drawWallOrDoor(x * cs, y * cs, (x + 1) * cs, y * cs, this.hWalls[y][x]);
                        }
                    }
                }
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x <= this.width; x++) {
                        if (this.vWalls[y][x].type > 0) {
                            this.drawWallOrDoor(x * cs, y * cs, x * cs, (y + 1) * cs, this.vWalls[y][x]);
                        }
                    }
                }
                ctx.stroke();
                this.drawWallOverlays();
                
                // 绘制鼠标悬停时的墙体预览
                if (this.editor.hoveredWall && !this.editor.isDragging) {
                    ctx.beginPath();
                    const {x, y, type, direction} = this.editor.hoveredWall;
                    
                    let wallType;
                    switch(this.editor.tool) {
                        case EDITOR_TOOLS.DOOR: wallType = WALL_TYPES.DOOR; break;
                        case EDITOR_TOOLS.GLASS: wallType = WALL_TYPES.GLASS; break;
                        case EDITOR_TOOLS.LOCK: wallType = WALL_TYPES.LOCKED; break;
                        case EDITOR_TOOLS.ONE_WAY: wallType = WALL_TYPES.ONE_WAY; break;
                        case EDITOR_TOOLS.LETTER_DOOR: wallType = WALL_TYPES.LETTER_DOOR; break; 
                        default: wallType = WALL_TYPES.SOLID;
                    }
                    const wallObject = { type: wallType, keys: '?', direction: direction };

                    if (type === 'h') {
                        this.drawWallOrDoor(x * cs, y * cs, (x + 1) * cs, y * cs, wallObject, true);
                    } else {
                        this.drawWallOrDoor(x * cs, y * cs, x * cs, (y + 1) * cs, wallObject, true);
                    }
                    ctx.stroke();

                    if (wallObject.type === WALL_TYPES.ONE_WAY && wallObject.direction) {
                        if (type === 'h') {
                            this.drawArrow(x * cs, y * cs, (x + 1) * cs, y * cs, direction, 'white', false);
                        } else {
                            this.drawArrow(x * cs, y * cs, x * cs, (y + 1) * cs, direction, 'white', false);
                        }
                    }
                }

               // 绘制所有实体
                this.items.forEach(item => this.drawItem(item));
                if (this.endPos) this.drawCircle(this.endPos.x, this.endPos.y, this.colors.endPoint);
                this.ghosts.forEach(g => this.drawCircle(g.x, g.y, this.colors.ghost));
                this.buttons.forEach(b => this.drawButton(b));
                this.drawCircle(this.startPos.x, this.startPos.y, this.colors.player);

                // 将按钮热点高亮移动到最后绘制，确保它在顶层
                if (this.editor.hoveredButtonHotspot) {
                    const virtualButton = {
                        x: this.editor.hoveredButtonHotspot.x,
                        y: this.editor.hoveredButtonHotspot.y,
                        direction: this.editor.hoveredButtonHotspot.direction
                    };
                    this.drawButton(virtualButton, true);
                }
            }
            
            /**
             * 获取鼠标在Canvas上的坐标
             * @param {MouseEvent|TouchEvent} e - 事件对象
             * @returns {object} 坐标 {x, y}
             */
            getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
            
            /**
             * 检查指定格子是否在固定的起始房间内
             */
            isPosInStartRoom(cellX, cellY) {
                const roomY = this.height - 3;
                return cellX >= 0 && cellX < 3 && cellY >= roomY && cellY < roomY + 3;
            }
            
            /**
             * 检查指定的墙体是否可被编辑（防止编辑外墙和起始房间的墙）
             */
            isWallEditable(wall) {
                if (!wall) return false;
                const {x, y, type} = wall;
                
                if (type === 'h' && (y === 0 || y === this.height)) return false;
                if (type === 'v' && (x === 0 || x === this.width)) return false;
                
                const roomY = this.height - 3;
                if (type === 'h' && y === roomY && x >= 0 && x < 3) return false;
                if (type === 'h' && y === roomY + 3 && x >= 0 && x < 3) return false;
                if (type === 'v' && x === 0 && y >= roomY && y < roomY + 3) return false;
                if (type === 'v' && x === 3 && y >= roomY && y < roomY + 3) return false;
                
                if (x >= 0 && x < 3 && y > roomY && y < roomY + 3) {
                     if (type === 'h') return false;
                }
                if (y >= roomY && y < roomY + 3 && x > 0 && x < 3) {
                     if (type === 'v') return false;
                }

                return true;
            }

            /**
             * 检查指定格子是否已被实体（终点、鬼、物品）占据
             */
            isCellOccupiedInEditor(x, y) {
                if (this.endPos && this.endPos.x === x && this.endPos.y === y) return true;
                if (this.ghosts.some(g => g.x === x && g.y === y)) return true;
                if (this.items.some(i => i.x === x && i.y === y)) return true;
                return false;
            }

            /**
             * 使用橡皮擦工具擦除指定位置的墙体或实体
             */
            eraseAtPos(pos) {
                const wall = this.getWallAtPos(pos.x, pos.y);
                if (wall && this.isWallEditable(wall)) {
                    if (wall.type === 'h') this.hWalls[wall.y][wall.x] = { type: WALL_TYPES.EMPTY, keys: 0 };
                    else this.vWalls[wall.y][wall.x] = { type: WALL_TYPES.EMPTY, keys: 0 };
                }

                const cellX = Math.floor(pos.x / this.cellSize);
                const cellY = Math.floor(pos.y / this.cellSize);
                if (!this.isPosInStartRoom(cellX, cellY)) {
                    if (this.endPos && this.endPos.x === cellX && this.endPos.y === cellY) {
                        this.endPos = null;
                    }
                    this.ghosts = this.ghosts.filter(g => g.x !== cellX || g.y !== cellY);
                    this.items = this.items.filter(i => i.x !== cellX || i.y !== cellY);
                }
                this.drawEditor();
            }

            /**
             * 处理游戏模式下的Canvas点击事件，用于玩家自动寻路移动
             */
            handleCanvasClick(e) {
                if (this.state !== GAME_STATES.PLAYING || this.editor.active) return;
                this.stopAutoMove();

                const pos = this.getMousePos(e);
                const targetX = Math.floor(pos.x / this.cellSize);
                const targetY = Math.floor(pos.y / this.cellSize);

                if (targetX < 0 || targetX >= this.width || targetY < 0 || targetY >= this.height) return;
                
                // 如果点击的是相邻格子，则直接移动
                const dx = targetX - this.player.x;
                const dy = targetY - this.player.y;
                if (Math.abs(dx) + Math.abs(dy) === 1) {
                    this.movePlayer(dx, dy);
                    return;
                }

                // 如果点击的是不可见区域，则不响应
                if (!this.seenCells[targetY][targetX] && !this.debugVision) return;

                // 寻路到目标点
                const path = this.findPlayerPath(this.player, {x: targetX, y: targetY});
                
                if (path && path.length > 1) {
                    let currentStep = 1;
                    const move = () => {
                        if (currentStep >= path.length || this.state !== GAME_STATES.PLAYING) {
                            this.stopAutoMove();
                            return;
                        }
                        const nextPos = path[currentStep];
                        const dx = nextPos.x - this.player.x;
                        const dy = nextPos.y - this.player.y;
                        this.movePlayer(dx, dy);
                        currentStep++;
                    };
                    move(); // 立即移动第一步
                    if (path.length > 2) {
                        this.autoMoveInterval = setInterval(move, 200); // 之后每隔200ms移动一步
                    }
                }
            }

            /**
             * 停止玩家的自动移动
             */
            stopAutoMove() {
                if (this.autoMoveInterval) {
                    clearInterval(this.autoMoveInterval);
                    this.autoMoveInterval = null;
                }
                if (this.dpadInterval) { 
                    clearInterval(this.dpadInterval);
                }
            }

            /**
             * 处理编辑器模式下的鼠标按下事件
             */
            handleCanvasMouseDown(e) {
                if (!this.editor.active) return;
                
                this.editor.isDragging = true;
                this.editor.didDrag = false;
                const pos = this.getMousePos(e);

                if (this.editor.tool === EDITOR_TOOLS.WALL || this.editor.tool === EDITOR_TOOLS.GLASS) { 
                    const wall = this.getWallAtPos(pos.x, pos.y);
                    if (wall && this.isWallEditable(wall)) {
                        this.editor.dragAxis = wall.type;
                        const type = this.editor.tool === EDITOR_TOOLS.GLASS ? WALL_TYPES.GLASS : WALL_TYPES.SOLID;
                        this.toggleWall(wall, type); 
                        this.editor.lastDragPos = wall;
                    } else {
                        this.editor.dragAxis = null;
                    }
                } else if (this.editor.tool === EDITOR_TOOLS.ERASER) {
                    this.eraseAtPos(pos);
                } else if (this.editor.tool === EDITOR_TOOLS.ONE_WAY) {
                    const wall = this.getWallAtPos(pos.x, pos.y);
                    if (wall && this.isWallEditable(wall)) {
                        const direction = this.getMouseSideOfWall(pos.x, pos.y, wall);
                        const newWall = { type: WALL_TYPES.ONE_WAY, direction: direction };
                        if (wall.type === 'h') this.hWalls[wall.y][wall.x] = newWall;
                        else this.vWalls[wall.y][wall.x] = newWall;
                        this.editor.lastDragPos = wall; 
                        this.drawEditor();
                    }
                }
            }

            /**
             * 处理编辑器模式下的鼠标移动事件
             */
            handleCanvasMouseMove(e) {
                if (!this.editor.active) return;

                const isWallTool = [EDITOR_TOOLS.WALL, EDITOR_TOOLS.DOOR, EDITOR_TOOLS.LOCK, EDITOR_TOOLS.ONE_WAY, EDITOR_TOOLS.GLASS, EDITOR_TOOLS.LETTER_DOOR].includes(this.editor.tool);

                if (!this.editor.isDragging) {
                    const pos = this.getMousePos(e);
                    let needsRedraw = false;

                    // 先处理墙体工具
                    if (isWallTool) {
                        const wall = this.getWallAtPos(pos.x, pos.y);
                        // 清除按钮高亮
                        if (this.editor.hoveredButtonHotspot) {
                            this.editor.hoveredButtonHotspot = null;
                            needsRedraw = true;
                        }
                        
                        if (wall && this.isWallEditable(wall)) {
                            // 检查悬停的墙体是否发生变化
                            if (!this.editor.hoveredWall || this.editor.hoveredWall.x !== wall.x || this.editor.hoveredWall.y !== wall.y || this.editor.hoveredWall.type !== wall.type) {
                                this.editor.hoveredWall = wall;
                                needsRedraw = true;
                            }
                            // 特别处理单向门的方向预览
                            if (this.editor.tool === EDITOR_TOOLS.ONE_WAY) {
                                const direction = this.getMouseSideOfWall(pos.x, pos.y, wall);
                                if (!this.editor.hoveredWall.direction || this.editor.hoveredWall.direction.dx !== direction.dx || this.editor.hoveredWall.direction.dy !== direction.dy) {
                                    this.editor.hoveredWall.direction = direction;
                                    needsRedraw = true;
                                }
                            }
                        } else if (this.editor.hoveredWall) {
                            this.editor.hoveredWall = null;
                            needsRedraw = true;
                        }
                    // 再处理按钮工具
                    } else if (this.editor.tool === EDITOR_TOOLS.BUTTON) {
                        const hotspot = this.getButtonHotspotAtPos(pos.x, pos.y);
                        // 清除墙体高亮
                        if (this.editor.hoveredWall) {
                            this.editor.hoveredWall = null;
                            needsRedraw = true;
                        }
                        if (hotspot?.x !== this.editor.hoveredButtonHotspot?.x || hotspot?.y !== this.editor.hoveredButtonHotspot?.y || hotspot?.direction.dx !== this.editor.hoveredButtonHotspot?.direction.dx) {
                             this.editor.hoveredButtonHotspot = hotspot;
                             needsRedraw = true;
                        }
                    // 其他工具则清除所有高亮
                    } else {
                        if (this.editor.hoveredWall) { this.editor.hoveredWall = null; needsRedraw = true; }
                        if (this.editor.hoveredButtonHotspot) { this.editor.hoveredButtonHotspot = null; needsRedraw = true; }
                    }

                    if (needsRedraw) {
                        this.drawEditor();
                    }
                    return;
                }

                // 处理拖动逻辑
                this.editor.didDrag = true;
                this.editor.hoveredWall = null;
                const pos = this.getMousePos(e);

                if ((this.editor.tool === EDITOR_TOOLS.WALL || this.editor.tool === EDITOR_TOOLS.GLASS) && this.editor.dragAxis) {
                    let wall;
                    if (this.editor.dragAxis === 'h') {
                        const x = Math.floor(pos.x / this.cellSize);
                        const y = this.editor.lastDragPos.y;
                        wall = { type: 'h', x, y };
                    } else {
                        const y = Math.floor(pos.y / this.cellSize);
                        const x = this.editor.lastDragPos.x;
                        wall = { type: 'v', x, y };
                    }
                    
                    if (wall && this.isWallEditable(wall) && (wall.x !== this.editor.lastDragPos.x || wall.y !== this.editor.lastDragPos.y)) {
                        const newType = this.editor.tool === EDITOR_TOOLS.GLASS ? WALL_TYPES.GLASS : WALL_TYPES.SOLID;
                        if (wall.type === 'h') this.hWalls[wall.y][wall.x] = { type: newType };
                        else this.vWalls[wall.y][wall.x] = { type: newType };
                        this.drawEditor();
                        this.editor.lastDragPos = wall;
                    }
                } else if (this.editor.tool === EDITOR_TOOLS.ERASER) {
                    this.eraseAtPos(pos);
                } else if (this.editor.tool === EDITOR_TOOLS.ONE_WAY && this.editor.lastDragPos) {
                    const wallData = this.editor.lastDragPos;
                    const newDirection = this.getMouseSideOfWall(pos.x, pos.y, wallData);
                    let currentWall = (wallData.type === 'h') ? this.hWalls[wallData.y][wallData.x] : this.vWalls[wallData.y][wallData.x];
                    if (currentWall && currentWall.type === WALL_TYPES.ONE_WAY && (currentWall.direction.dx !== newDirection.dx || currentWall.direction.dy !== newDirection.dy)) {
                        currentWall.direction = newDirection;
                        this.drawEditor();
                    }
                }
            }
            
            /**
             * 处理编辑器模式下的鼠标松开事件
             */
            handleCanvasMouseUp(e) {
                if (!this.editor.active) return;

                // 如果没有发生拖动，则视为单击事件
                if (this.editor.isDragging && !this.editor.didDrag) {
                    const pos = this.getMousePos(e);
                    const cellX = Math.floor(pos.x / this.cellSize);
                    const cellY = Math.floor(pos.y / this.cellSize);
                    
                    const wall = this.getWallAtPos(pos.x, pos.y);
                    if (wall && this.isWallEditable(wall)) {
                        if (this.editor.tool === EDITOR_TOOLS.DOOR) {
                            if (wall.type === 'h') {
                                const currentType = this.hWalls[wall.y][wall.x].type;
                                this.hWalls[wall.y][wall.x] = { type: currentType === WALL_TYPES.DOOR ? WALL_TYPES.EMPTY : WALL_TYPES.DOOR, keys: 0 };
                            } else {
                                const currentType = this.vWalls[wall.y][wall.x].type;
                                this.vWalls[wall.y][wall.x] = { type: currentType === WALL_TYPES.DOOR ? WALL_TYPES.EMPTY : WALL_TYPES.DOOR, keys: 0 };
                            }
                        } else if (this.editor.tool === EDITOR_TOOLS.LOCK) {
                            const numStr = prompt('请输入锁需要的钥匙数量:', '0');
                            if (numStr !== null) {
                                const keys = parseInt(numStr);
                                if (!isNaN(keys) && keys >= 0) {
                                    if (wall.type === 'h') this.hWalls[wall.y][wall.x] = { type: WALL_TYPES.LOCKED, keys: keys };
                                    else this.vWalls[wall.y][wall.x] = { type: WALL_TYPES.LOCKED, keys: keys };
                                } else {
                                    this.showToast('请输入一个有效的非负整数。', 3000, 'error');
                                }
                            }
                        } else if (this.editor.tool === EDITOR_TOOLS.LETTER_DOOR) { 
                            const wallRef = wall.type === 'h' ? this.hWalls[wall.y][wall.x] : this.vWalls[wall.y][wall.x];
                            if (wallRef.type === WALL_TYPES.LETTER_DOOR) {
                                // 如果已是字母门，切换初始状态
                                wallRef.initialState = (wallRef.initialState === 'open') ? 'closed' : 'open';
                            } else {
                                // 创建新字母门

                                const letter = prompt('请输入一个字母:', 'A');
                                if (letter && /^[a-zA-Z]$/.test(letter)) {
                                    const newWall = { type: WALL_TYPES.LETTER_DOOR, letter: letter.toUpperCase(), initialState: 'closed' };
                                    if (wall.type === 'h') this.hWalls[wall.y][wall.x] = newWall;
                                    else
 this.vWalls[wall.y][wall.x] = newWall;
                                } else
 if (letter !== null) {
                                    this.showToast('请输入单个英文字母。', 3000, 'error');
                                }
                            }
                        }
                    }
                    
                    // 处理按钮工具的点击
                    if (this.editor.tool === EDITOR_TOOLS.BUTTON) {
                        const hotspot = this.getButtonHotspotAtPos(pos.x, pos.y);
                        if (hotspot) {
                            const existingButtonIndex = this.buttons.findIndex(b => b.x === hotspot.x && b.y === hotspot.y && b.direction.dx === hotspot.direction.dx && b.direction.dy === hotspot.direction.dy);
                            if (existingButtonIndex > -1) {
                                // 如果按钮已存在，则删除
                                this.buttons.splice(existingButtonIndex, 1);
                            } else {
                                // 创建新按钮
                                const letter = prompt('请输入一个字母:', 'A');
                                if (letter && /^[a-zA-Z]$/.test(letter)) {
                                    this.buttons.push({ ...hotspot, letter: letter.toUpperCase() });
                                } else if (letter !== null) {
                                    this.showToast('请输入单个英文字母。', 3000, 'error');
                                }
                            }
                        }
                    }

                    // 处理在格子上放置实体的逻辑
                    if (!this.isPosInStartRoom(cellX, cellY)) {
                        const existingItemIndex = this.items.findIndex(i => i.x === cellX && i.y === cellY);
                        const isOccupied = this.isCellOccupiedInEditor(cellX, cellY);

                        switch (this.editor.tool) {
                            case EDITOR_TOOLS.END:
                                if (!isOccupied || (this.endPos && this.endPos.x === cellX && this.endPos.y === cellY)) {
                                    this.endPos = { x: cellX, y: cellY };
                                }
                                break;
                            case EDITOR_TOOLS.GHOST:
                                const existingGhostIndex = this.ghosts.findIndex(g => g.x === cellX && g.y === cellY);
                                if (existingGhostIndex > -1) this.ghosts.splice(existingGhostIndex, 1);
                                else if (!isOccupied) this.ghosts.push({ x: cellX, y: cellY });
                                break;
                            case EDITOR_TOOLS.KEY:
                                if (existingItemIndex > -1 && this.items[existingItemIndex].type === 'key') this.items.splice(existingItemIndex, 1);
                                else if (!isOccupied) this.items.push({ x: cellX, y: cellY, type: 'key' });
                                break;
                        }
                    }
                    this.drawEditor();
                }
                
                // 重置拖动状态
                this.editor.isDragging = false;
                this.editor.didDrag = false;
                this.editor.dragAxis = null;
                this.editor.lastDragPos = null;
            }
            
            /**
             * 处理鼠标离开Canvas的事件，重置编辑器状态
             */
            handleCanvasMouseLeave(e) {
                if (this.editor.hoveredWall) {
                    this.editor.hoveredWall = null;
                    this.drawEditor();
                }
                this.editor.isDragging = false;
                this.editor.didDrag = false;
                this.editor.dragAxis = null;
                this.editor.lastDragPos = null;
            }
            
            /**
             * 根据鼠标坐标获取其附近的墙体
             */
            getWallAtPos(mouseX, mouseY) {
                const cs = this.cellSize;
                const tolerance = cs / 5;
                const gridX = mouseX / cs;
                const gridY = mouseY / cs;
                const x = Math.floor(gridX);
                const y = Math.floor(gridY);
                
                const nearHorizontal = Math.abs(gridY - Math.round(gridY)) * cs < tolerance;
                const nearVertical = Math.abs(gridX - Math.round(gridX)) * cs < tolerance;
                
                if (nearHorizontal && !nearVertical) return { type: 'h', x: x, y: Math.round(gridY) };
                if (nearVertical && !nearHorizontal) return { type: 'v', x: Math.round(gridX), y: y };
                return null;
            }
            
            /**
             * [编辑器] 根据鼠标坐标获取其所在的按钮热点区域
             * @returns {object|null} 热点信息或null
             */
            getButtonHotspotAtPos(mouseX, mouseY) {
                const cs = this.cellSize;
                const cellX = Math.floor(mouseX / cs);
                const cellY = Math.floor(mouseY / cs);

                // 鼠标在单元格内的相对坐标
                const localX = mouseX - cellX * cs;
                const localY = mouseY - cellY * cs;

                let direction = null;
                // 使用对角线划分四个三角形区域
                if (localY < localX && localY < -localX + cs) {
                    direction = { dx: 0, dy: -1 }; // Top
                } else if (localY > localX && localY > -localX + cs) {
                    direction = { dx: 0, dy: 1 }; // Bottom
                } else if (localY > localX && localY < -localX + cs) {
                    direction = { dx: -1, dy: 0 }; // Left
                } else if (localY < localX && localY > -localX + cs) {
                    direction = { dx: 1, dy: 0 }; // Right
                }

                if (!direction) return null;

                // 检查热点旁边是否有墙
                let wallExists = false;
                if (direction.dy === -1 && this.hWalls[cellY][cellX].type > 0) wallExists = true;
                if (direction.dy === 1 && this.hWalls[cellY + 1][cellX].type > 0) wallExists = true;
                if (direction.dx === -1 && this.vWalls[cellY][cellX].type > 0) wallExists = true;
                if (direction.dx === 1 && this.vWalls[cellY][cellX + 1].type > 0) wallExists = true;
                
                if (wallExists) {
                    // 检查这堵墙是否是起始房间的边界墙
                    const roomYStart = this.height - 3;
                    const isTopBoundary = direction.dy === -1 && cellY === roomYStart && cellX >= 0 && cellX < 3;
                    const isRightBoundary = direction.dx === 1 && cellX === 2 && cellY >= roomYStart && cellY < this.height;

                    // 如果是起始房间的边界墙，则不允许放置按钮
                    if (isTopBoundary || isRightBoundary) {
                        return null;
                    }

                    return { x: cellX, y: cellY, direction: direction };
                }
                return null;
            }

            /**
             * 切换指定墙体的类型（开/关）
             */
            toggleWall(wall, targetType = WALL_TYPES.SOLID) {
                const {x, y, type} = wall;
                if (type === 'h' && y >= 0 && y <= this.height && x >= 0 && x < this.width) {
                    this.hWalls[y][x].type = this.hWalls[y][x].type === targetType ? WALL_TYPES.EMPTY : targetType;
                } else if (type === 'v' && x >= 0 && x <= this.width && y >= 0 && y < this.height) {
                    this.vWalls[y][x].type = this.vWalls[y][x].type === targetType ? WALL_TYPES.EMPTY : targetType;
                }
                this.drawEditor();
            }
            
            /**
             * 切换指定墙体的类型（开/关）
             */
            toggleWall(wall, targetType = WALL_TYPES.SOLID) {
                const {x, y, type} = wall;
                if (type === 'h' && y >= 0 && y <= this.height && x >= 0 && x < this.width) {
                    this.hWalls[y][x].type = this.hWalls[y][x].type === targetType ? WALL_TYPES.EMPTY : targetType;
                } else if (type === 'v' && x >= 0 && x <= this.width && y >= 0 && y < this.height) {
                    this.vWalls[y][x].type = this.vWalls[y][x].type === targetType ? WALL_TYPES.EMPTY : targetType;
                }
                this.drawEditor();
            }

            // ==================================================
            //  工具函数 (寻路, 分享码等)
            // ==================================================
            
            /**
             * 判断鼠标在墙体的哪一侧，用于确定单向门的方向
             */
            getMouseSideOfWall(mouseX, mouseY, wall) {
                const cs = this.cellSize;
                if (wall.type === 'h') {
                    return (mouseY > wall.y * cs) ? { dx: 0, dy: 1 } : { dx: 0, dy: -1 };
                } else {
                    return (mouseX > wall.x * cs) ? { dx: 1, dy: 0 } : { dx: -1, dy: 0 };
                }
            }

            /**
             * 使用广度优先搜索(BFS)计算从起点到地图上所有点的最短距离
             */
            calculateDistances(startNode) {
                const distances = Array(this.height).fill(null).map(() => Array(this.width).fill(Infinity));
                const queue = [{ x: startNode.x, y: startNode.y, dist: 0 }];
                distances[startNode.y][startNode.x] = 0;

                while (queue.length > 0) {
                    const { x, y, dist } = queue.shift();
                    const neighbors = [ {dx:0, dy:-1}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:-1, dy:0} ];
                    for (const {dx, dy} of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                            let wall;
                            if (dx === 1) wall = this.vWalls[y][x + 1];
                            if (dx === -1) wall = this.vWalls[y][x];
                            if (dy === 1) wall = this.hWalls[y + 1][x];
                            if (dy === -1) wall = this.hWalls[y][x];

                            if (wall && [WALL_TYPES.SOLID, WALL_TYPES.LOCKED, WALL_TYPES.ONE_WAY].includes(wall.type)) continue;
                            
                            if (distances[ny][nx] === Infinity) {
                                distances[ny][nx] = dist + 1;
                                queue.push({ x: nx, y: ny, dist: dist + 1 });
                            }
                        }
                    }
                }
                return distances;
            }
            
            /**
             * 使用BFS为鬼寻找通往目标的最短路径 (不考虑门的状态)
             */
            findShortestPath(start, end) {
                const queue = [[{x: start.x, y: start.y}]];
                const visited = new Set([`${start.x},${start.y}`]);

                while (queue.length > 0) {
                    const path = queue.shift();
                    const { x, y } = path[path.length - 1];

                    if (x === end.x && y === end.y) return path;

                    const neighbors = [ {dx:0, dy:-1}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:-1, dy:0} ];
                    for (const {dx, dy} of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        const key = `${nx},${ny}`;

                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !visited.has(key)) {
                            let wall;
                            if (dx === 1) wall = this.vWalls[y][x + 1];
                            else if (dx === -1) wall = this.vWalls[y][x];
                            else if (dy === 1) wall = this.hWalls[y + 1][x];
                            else if (dy === -1) wall = this.hWalls[y][x];

                            if (wall && wall.type > 0 && !(wall.type === WALL_TYPES.LETTER_DOOR && wall.currentState === 'open')) {
                                continue;
                            }
                            
                            visited.add(key);
                            const newPath = [...path, {x: nx, y: ny}];
                            queue.push(newPath);
                        }
                    }
                }
                return null;
            }

            /**
             * 使用BFS为玩家寻找通往目标的最短路径 (考虑视野和门的状态)
             */
            findPlayerPath(start, end) {
                const queue = [[{x: start.x, y: start.y}]];
                const visited = new Set([`${start.x},${start.y}`]);

                while (queue.length > 0) {
                    const path = queue.shift();
                    const { x, y } = path[path.length - 1];

                    if (x === end.x && y === end.y) return path;

                    const neighbors = [ {dx:0, dy:-1}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:-1, dy:0} ];
                    for (const {dx, dy} of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        const key = `${nx},${ny}`;

                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !visited.has(key)) {
                            if (!this.seenCells[ny][nx] && !this.debugVision) continue;
                            
                            let wall;
                            let isBlocked = false;
                            if (dx === 1) wall = this.vWalls[y][x + 1];
                            else if (dx === -1) wall = this.vWalls[y][x];
                            else if (dy === 1) wall = this.hWalls[y + 1][x];
                            else if (dy === -1) wall = this.hWalls[y][x];

                            if (wall) {
                                if (wall.type === WALL_TYPES.SOLID || wall.type === WALL_TYPES.GLASS || (wall.type === WALL_TYPES.LOCKED && this.player.keys < wall.keys)) {
                                    isBlocked = true;
                                } else if (wall.type === WALL_TYPES.ONE_WAY) {
                                    if (dx !== wall.direction.dx || dy !== wall.direction.dy) {
                                        isBlocked = true;
                                    }
                                }
                            }
                            if (isBlocked) continue;
                            
                            visited.add(key);
                            const newPath = [...path, {x: nx, y: ny}];
                            queue.push(newPath);
                        }
                    }
                }
                return null;
            }           
            
            /**
             * [私有] 从剪贴板读取文本并调用加载函数
             * @param {boolean} isEditor - 是否加载到编辑器
             */
            async _loadCodeFromClipboard(isEditor = false) {
                try {
                    const code = await navigator.clipboard.readText();
                    if (code) {
                        this.loadFromShareCode(code, isEditor);
                    } else {
                        this.showToast('剪贴板为空。', 3000, 'error');
                    }
                } catch (err) {
                    console.error('无法读取剪贴板内容: ', err);
                    this.showToast('无法读取剪贴板。请检查浏览器权限。', 3000, 'error');
                }
            }

            /**
             * 生成地图的分享码
             * @param {boolean} isEditor - 是否为编辑器模式生成
             * @returns {string|null} 分享码或null
             */
            generateShareCode(isEditor = false) {
                try {
                    let sourceData;
                    if (isEditor) {
                        sourceData = {
                            width: this.width, height: this.height,
                            hWalls: this.hWalls, vWalls: this.vWalls,
                            endPos: this.endPos, initialGhosts: this.ghosts, items: this.items,
                            buttons: this.buttons,
                            gameMode: this.gameMode,
                            initialHealth: parseInt(document.getElementById('editor-initial-health').value) || 5,
                            initialStamina: parseInt(document.getElementById('editor-initial-stamina').value) || 100
                        };
                    } else {
                        if (!this.mapData) return null;
                        sourceData = {
                            width: this.mapData.width, height: this.mapData.height,
                            hWalls: this.mapData.hWalls, vWalls: this.mapData.vWalls,
                            endPos: this.mapData.endPos, initialGhosts: this.mapData.initialGhosts, items: this.mapData.items,
                            gameMode: this.gameMode, initialHealth: this.initialHealth, initialStamina: this.initialStamina
                        };
                    }

                    // 统一的数据结构
                    const mapSource = {
                        w: sourceData.width, h: sourceData.height,
                        hw: sourceData.hWalls, vw: sourceData.vWalls,
                        e: sourceData.endPos, g: sourceData.initialGhosts, i: sourceData.items,
                        b: sourceData.buttons,
                        gm: sourceData.gameMode, ih: sourceData.initialHealth, is: sourceData.initialStamina
                    };

                    // 流程: 对象 -> JSON字符串 -> pako压缩 -> 二进制字符串 -> Base64编码
                    const jsonString = JSON.stringify(mapSource);
                    const compressedData = pako.deflate(jsonString);
                    const binaryString = String.fromCharCode.apply(null, compressedData);
                    const shareCode = btoa(binaryString);
                    
                    return shareCode;

                } catch (e) {
                    console.error("生成分享码失败:", e);
                    this.showToast('生成分享码失败。', 3000, 'error');
                    return null;
                }
            }

            /**
             * 从分享码加载地图
             * @param {string} code - 分享码
             * @param {boolean} isEditor - 是否加载到编辑器
             */
            loadFromShareCode(code, isEditor = false) {
                if (!code) {
                    this.showToast('请输入分享码。', 3000, 'error');
                    return;
                }
                try {
                    // 流程: Base64解码 -> 二进制数据 -> pako解压 -> JSON字符串 -> 对象
                    const binaryString = atob(code);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const jsonString = pako.inflate(bytes, { to: 'string' });
                    const data = JSON.parse(jsonString);

                    if (!data.w || !data.h || !data.hw || !data.vw) {
                        throw new Error("无效的地图数据结构");
                    }

                    const mapData = {
                        width: data.w, height: data.h,
                        hWalls: data.hw, vWalls: data.vw,
                        endPos: data.e || null,
                        initialGhosts: data.g || [],
                        items: data.i || [],
                        buttons: data.b || [] 
                    };

                    const loadedMode = data.gm || 'exploration';
                    const loadedHealth = data.ih || 5;
                    const loadedStamina = data.is || 100;

                    if (isEditor) {
                        this.setGameMode(loadedMode, true); 
                        document.getElementById('editor-initial-health').value = loadedHealth;
                        document.getElementById('editor-initial-stamina').value = loadedStamina;

                        this.width = mapData.width;
                        this.height = mapData.height;
                        this.editorMapSizeInput.value = this.width;
                        this.cellSize = canvas.width / this.width;
                        this.hWalls = mapData.hWalls;
                        this.vWalls = mapData.vWalls;
                        this.endPos = mapData.endPos;
                        this.ghosts = mapData.initialGhosts;
                        this.items = mapData.items;
                        
                        this._renderStaticLayer(); // 加载新地图后重绘静态层
                        this.drawEditor();
                    } else {
                        this.initialHealth = loadedHealth;
                        this.initialStamina = loadedStamina;
                        this.setGameMode(loadedMode);
                        this.startGame(mapData);
                    }
                    this.showToast('地图加载成功！', 2000, 'success');

                } catch (e) {
                    console.error("加载分享码失败:", e);
                    this.showToast('加载分享码失败，格式不正确或已损坏。', 3000, 'error');
                }
            }

            // ==================================================
            //  历史与撤销系统
            // ==================================================

            /**
             * 创建当前游戏状态的快照
             * @param {boolean} isRevivalPoint - 是否为复活点/存档点
             * @returns {object} 状态快照对象
             */
            createSnapshot(isRevivalPoint = false) {
                return {
                    player: JSON.parse(JSON.stringify(this.player)),
                    ghosts: JSON.parse(JSON.stringify(this.ghosts)),
                    items: JSON.parse(JSON.stringify(this.items)),
                    // 墙体状态需要深拷贝，特别是字母门的currentState
                    hWalls: JSON.parse(JSON.stringify(this.hWalls)),
                    vWalls: JSON.parse(JSON.stringify(this.vWalls)),
                    isRevivalPoint: isRevivalPoint
                };
            }

            /**
             * 从快照恢复游戏状态
             * @param {object} snapshot - 状态快照对象
             */
            loadFromSnapshot(snapshot) {
                this.player = JSON.parse(JSON.stringify(snapshot.player));
                this.ghosts = JSON.parse(JSON.stringify(snapshot.ghosts));
                this.items = JSON.parse(JSON.stringify(snapshot.items));
                this.hWalls = JSON.parse(JSON.stringify(snapshot.hWalls));
                this.vWalls = JSON.parse(JSON.stringify(snapshot.vWalls));
                
                this.updateUIDisplays();
                this.draw();
            }

            /**
             * 记录当前状态到历史记录中
             * @param {boolean} isRevivalPoint - 当前状态是否为复活点
             */
            recordHistory(isRevivalPoint = false) {
                // 如果在撤销后走了新的分支，则截断旧的未来历史
                if (this.currentStep < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentStep + 1);
                    this.checkpoints = this.checkpoints.filter(cp => cp <= this.currentStep);
                }
                
                const snapshot = this.createSnapshot(isRevivalPoint);
                this.history.push(snapshot);
                this.currentStep++;
                
                this.updateHistoryButtons();
            }

            /**
             * 更新撤销、存档、回溯按钮的可用状态
             */
            updateHistoryButtons() {
                const undoBtn = document.getElementById('undo-btn');
                const saveBtn = document.getElementById('save-btn');
                const rewindBtn = document.getElementById('rewind-btn');

                // 只有在当前步数不是第一步且不是复活点时才能撤销
                const canUndo = this.currentStep > 0 && !this.history[this.currentStep].isRevivalPoint;
                undoBtn.disabled = !canUndo;

                // 只有在当前步数比上一个存档点更晚时才能存档
                const lastCheckpoint = this.checkpoints.length > 0 ? this.checkpoints[this.checkpoints.length - 1] : -1;
                const canSave = this.currentStep > lastCheckpoint;
                saveBtn.disabled = !canSave;

                // 只有存在比当前步数更早的存档点时才能回溯
                const canRewind = this.checkpoints.some(cp => cp < this.currentStep);
                rewindBtn.disabled = !canRewind;
            }

            /**
             * 处理撤销操作
             */
            handleUndo() {
                if (this.currentStep <= 0) return;
                if (this.history[this.currentStep].isRevivalPoint) {
                    this.showToast('无法撤回到上一次生命', 2000, 'error');
                    return;
                }
                
                this.currentStep--;
                this.loadFromSnapshot(this.history[this.currentStep]);
                this.updateHistoryButtons();
            }

            /**
             * 处理存档操作
             */
            handleSave() {
                const lastCheckpoint = this.checkpoints.length > 0 ? this.checkpoints[this.checkpoints.length - 1] : -1;
                if (this.currentStep <= lastCheckpoint) {
                    this.showToast('请先移动后再存档', 2000, 'error');
                    return;
                }

                this.checkpoints.push(this.currentStep);
                this.showToast(`已在第 ${this.currentStep} 步创建存档`, 2000, 'success');
                this.updateHistoryButtons();
            }

            /**
             * 处理回溯到上一个存档点的操作
             */
            handleRewind() {
                // 找到所有比当前步数早的存档点
                const availableCheckpoints = this.checkpoints.filter(cp => cp < this.currentStep);
                if (availableCheckpoints.length === 0) {
                    this.showToast('没有更早的存档点可供回溯', 2000, 'error');
                    return;
                }

                // 回溯到最近的一个早期存档点
                const targetStep = Math.max(...availableCheckpoints);
                this.currentStep = targetStep;
                this.loadFromSnapshot(this.history[this.currentStep]);
                this.updateHistoryButtons();
                this.showToast(`已回溯至存档点 (第 ${targetStep} 步)`, 2000, 'success');
            }

            /**
             * 生成分享码并复制到剪贴板
             */
            copyShareCode(isEditor = false) {
                const code = this.generateShareCode(isEditor);
                if (code) {
                    navigator.clipboard.writeText(code).then(() => {
                        this.showToast('分享码已复制到剪贴板！', 2000, 'success');
                    }, () => {
                        this.showToast('复制分享码失败。', 3000, 'error');
                    });
                } else {
                    this.showToast('无法生成分享码，请先创建地图。', 3000, 'error');
                }
            }
        }

        // 创建游戏实例
        const game = new GhostMazeGame();
    });
    </script>
        <div id="dpad-controls" style="display: none;">
            <div id="dpad-up" class="dpad-btn">▲</div>
            <div id="dpad-left" class="dpad-btn">◀</div>
            <div id="dpad-grip"></div> <!-- 新增的拖动把手 -->
            <div id="dpad-right" class="dpad-btn">▶</div>
            <div id="dpad-down" class="dpad-btn">▼</div>
        </div>
    </body>
</html>
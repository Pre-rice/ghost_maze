<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>鬼迷宫</title>
        <style>
        :root {
            --bg-color: #f0f2f5;
            --danger-bg-color: #680e0e;
            --container-bg: #ffffff;
            --text-color: #333;
            --border-color: #d9d9d9;
            --primary-color: #1890ff;
            --primary-hover-color: #40a9ff;
            --danger-color: #ff4d4f;
            --danger-hover-color: #ff7875;
            --success-color: #52c41a;
            --disabled-color: #f5f5f5;
            --disabled-text-color: #bfbfbf;

            /* Game Colors */
            --ground-color: #dfe3e6;
            --grid-line-color: #dadee1;
            --unexplored-color: #0b0b0b;
            --wall-color: #495360;
            --player-color: #007bff;
            --ghost-color: #dc3545;
            --end-point-color: #28a745;
            --key-color: #ffc107;
            --start-room-highlight: rgba(173, 216, 230, 0.4);
            --hover-highlight-color: #ffc107;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            box-sizing: border-box;
            transition: background-color 0.25s ease; /* Faster transition */
        }

        body.danger-bg {
            background-color: var(--danger-bg-color);
        }

        .main-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }

        #game-canvas {
            border: 1px solid var(--border-color);
            background-color: var(--container-bg);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            cursor: pointer;
        }

        .controls-panel {
            width: 280px;
            padding:15px;
            background-color: var(--container-bg);
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
            border: 1px solid var(--border-color);
            padding: 10px;
            border-radius: 6px;
        }

        .control-group h3 {
            margin: 0;
            font-size: 16px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }
        
        .control-group .status-bar {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .control-group label, .control-group .label {
            font-weight: 500;
            font-size: 14px;
        }

        #ghost-proximity-display.warning {
            color: var(--danger-color);
            font-weight: bold;
        }

        .control-group input[type="number"], .control-group input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
        }

        button, .button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            background-color: var(--primary-color);
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
            text-align: center;
        }

        button:hover, .button:hover {
            background-color: var(--primary-hover-color);
        }
        
        button.secondary {
            background-color: #6c757d;
        }
        button.secondary:hover {
            background-color: #5a6268;
        }
        
        button.danger {
            background-color: var(--danger-color);
        }
        button.danger:hover {
            background-color: var(--danger-hover-color);
        }

        button:disabled {
            background-color: var(--disabled-color);
            color: var(--disabled-text-color);
            cursor: not-allowed;
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .toggle-switch input[type="checkbox"] {
            height: 0;
            width: 0;
            visibility: hidden;
        }

        .toggle-switch label {
            cursor: pointer;
            text-indent: -9999px;
            width: 50px;
            height: 25px;
            background: grey;
            display: block;
            border-radius: 100px;
            position: relative;
        }

        .toggle-switch label:after {
            content: '';
            position: absolute;
            top: 2.5px;
            left: 2.5px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 90px;
            transition: 0.3s;
        }

        .toggle-switch input:checked + label {
            background: var(--primary-color);
        }

        .toggle-switch input:checked + label:after {
            left: calc(100% - 2.5px);
            transform: translateX(-100%);
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: none; /* Initially hidden */
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .overlay-content {
            background-color: var(--container-bg);
            padding: 30px 40px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        .overlay-content h2, .overlay-content p {
            margin-top: 0;
            margin-bottom: 1em;
        }

        .overlay-content .buttons {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        
        .editor-toolbar {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .share-buttons-container {
            display: flex;
            gap: 10px;
        }
        .share-buttons-container button {
            flex: 1; /* 让两个按钮平分宽度 */
        }
        
        .editor-toolbar button.active {
            background-color: var(--primary-hover-color);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        /* === Toast Notification Styles === */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translate(-50%, -100px);
            padding: 12px 20px;
            border-radius: 6px;
            background-color: var(--primary-color);
            color: white;
            font-size: 15px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: transform 0.4s ease, opacity 0.4s ease, visibility 0.4s;
        }
        .toast.show {
            transform: translate(-50%, 0);
            opacity: 1;
            visibility: visible;
        }
        .toast.success {
            background-color: var(--success-color);
        }
        .toast.error {
            background-color: var(--danger-color);
        }
        /* === 新增：用于将标签和输入框放在一行的样式 === */
        .inline-control-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px; /* 在标签和输入框之间增加一点间距 */
        }
        /* === 新增：限制行内输入框的宽度，使其不再占满剩余空间 === */
        .inline-control-group input[type="number"] {
            width: 50%; /* 设置输入框宽度为父容器的一半 */
        }
        #game-canvas {
         -webkit-tap-highlight-color: transparent; /* 核心改动：移除移动端点击时的蓝色高亮效果 */
        }
        
        /* === 新增：模式选择器样式 === */
        .mode-selector {
            display: flex;
            width: 100%;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }
        .mode-btn {
            flex: 1;
            padding: 8px;
            border: none;
            background-color: var(--container-bg);
            color: var(--text-color);
            cursor: pointer;
            transition: background-color 0.2s, color 0.2s;
            border-radius: 0;
        }
        .mode-btn:not(:last-child) {
            border-right: 1px solid var(--border-color);
        }
        .mode-btn.active {
            background-color: var(--primary-color);
            color: white;
            font-weight: bold;
        }
        .mode-btn:not(.active):hover {
            background-color: #f0f0f0;
        }

        /* === 移动端适配媒体查询 === */
        /* 当屏幕宽度小于等于 768px 时，应用以下样式 */
        @media (max-width: 768px) {
            body {
                padding: 10px; /* 为小屏幕调整内边距，避免内容紧贴边缘 */
                align-items: flex-start; /* 恢复默认的顶部对齐 */
            }

            .main-container {
                flex-direction: column; /* 核心改动：将主容器的布局从水平并排变为垂直堆叠 */
                gap: 15px; /* 调整画布和控制面板垂直堆叠时的间距 */
                width: 100%;
            }

            #game-canvas {
                width: 100%; /* 让画布宽度占满容器宽度 */
                height: auto; /* 高度自动调整，以保持其原始的1:1宽高比 */
                order: 1; /* 视觉上确保画布在控制面板的上方 */
            }

            .controls-panel {
                width: 100%; /* 控制面板也占满容器宽度 */
                order: 2; /* 视觉上确保控制面板在画布的下方 */
                padding: 15px; /* 可以在小屏幕上稍微减少一点内边距 */
                box-sizing: border-box; /* 确保padding不会撑大宽度 */
            }

            /* 调整游戏结束、胜利等浮窗在小屏幕上的表现 */
            .overlay-content {
                padding: 20px 15px;
                width: 90%; /* 避免浮窗宽度紧贴屏幕边缘 */
                box-sizing: border-box;
            }

            .overlay-content h2 {
                font-size: 1.5rem; /* 适当调整标题字体大小 */
            }

            /* 在小屏幕上，浮窗里的按钮也垂直堆叠，更易于点击 */
            .overlay-content .buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .overlay-content .buttons button {
                width: 100%; /* 让每个按钮都更容易点击 */
            }
            
            /* 调整编辑器工具栏，允许其在空间不足时换行并居中 */
            .editor-toolbar {
                justify-content: center;
            }

        @media (max-width: 768px) {
            #dpad-controls {
                display: grid !important;
                grid-template-columns: 60px 60px 60px;
                grid-template-rows: 60px 60px 60px;
                position: fixed;
                bottom: 20px;
                right: 20px;
                opacity: 0.7;
                z-index: 100;
                background-color: transparent;
                touch-action: none;
                transform-origin: center center;
            }

            .dpad-btn {
                background-color: #333;
                color: white;
                border: 2px solid #555;
                border-radius: 10px;
                font-size: 24px;
                display: flex;
                justify-content: center;
                align-items: center;
                user-select: none;
                -webkit-user-select: none;
                cursor: pointer;
            }

            #dpad-up { grid-column: 2; grid-row: 1; }
            #dpad-down { grid-column: 2; grid-row: 3; }
            #dpad-left { grid-column: 1; grid-row: 2; }
            #dpad-right { grid-column: 3; grid-row: 2; }
            
            /* === 新增: 拖动把手的样式 === */
            #dpad-grip {
                grid-column: 2;
                grid-row: 2;
                background-color: rgba(85, 85, 85, 0.8);
                border-radius: 50%;
                cursor: move;
                border: 2px solid #333;
            }

            .dpad-btn:active {
                background-color: #555;
                transform: scale(0.95);
            }
        }
        }

/* 1. 开关父容器的基础布局 */
.toggle-controls-wrapper {
    display: flex;
    align-items: center;
    gap: 15px; /* 仅在移动端两个开关并存时生效 */
    /* 默认靠左对齐，适用于电脑端只有一个开关的情况 */
    justify-content: flex-start; 
}

/* 2. 每个开关的基础样式 */
.toggle-controls-wrapper .toggle-switch {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%; /* 默认让开关占满父容器宽度 */
}

/* 3. 默认隐藏方向键开关 */
#dpad-toggle-container {
    display: none;
}

/* 4. 仅在移动端 (屏幕宽度 <= 768px) 应用特殊布局 */
@media (max-width: 768px) {
    /* 在移动端，让父容器的对齐方式变为 space-between */
    .toggle-controls-wrapper {
        justify-content: space-between;
    }

    /* 在移动端，让每个开关只占大约一半的宽度 */
    .toggle-controls-wrapper .toggle-switch {
        width: 48%;
    }

    /* 在移动端，显示方向键开关 */
    #dpad-toggle-container {
        display: flex;
    }
}

/* 用于通过JS来强制隐藏方向键的类 */
#dpad-controls.hidden {
    display: none !important;
}
    </style>
    </head>
    <body>

        <div class="main-container">
            <canvas id="game-canvas" width="600" height="600"></canvas>

            <div class="controls-panel">
                <!-- Game Mode UI -->
                <div id="game-controls">
                    <div class="control-group">
                        <h3>状态</h3>
                        <!-- 探索模式状态栏 -->
                        <div id="status-bar-exploration" class="status-bar">
                            <div id="player-health-display" class="label">生命:
                                5</div>
                            <div id="player-keys-display" class="label">钥匙:
                                0</div>
                            <div id="player-steps-display" class="label">步数:
                                0</div>
                            <div id="ghost-proximity-display"
                                class="label">周围鬼数: 0</div>
                        </div>
                        <!-- 死亡循环模式状态栏 -->
                        <div id="status-bar-death-loop" class="status-bar"
                            style="display: none;">
                            <div id="loop-count-display" class="label">循环次数:
                                0</div>
                            <div id="player-keys-display-death-loop"
                                class="label">钥匙: 0</div>
                            <div id="player-stamina-display" class="label">剩余体力:
                                100</div>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>地图选项</h3>
                        <label class="label">模式选择</label>
                        <div class="mode-selector">
                            <button id="mode-exploration-btn"
                                class="mode-btn active">探索模式</button>
                            <button id="mode-death-loop-btn"
                                class="mode-btn">死亡循环</button>
                        </div>
                        <div class="inline-control-group">
                            <label for="map-size-input">地图大小 (8-20):</label>
                            <input type="number" id="map-size-input" value="10"
                                min="8" max="20">
                        </div>
                        <button id="generate-map-btn">随机生成新地图</button>
                    </div>
                    <div class="control-group">
                        <h3>分享</h3>
                        <div class="share-buttons-container">
                            <button id="copy-share-code-btn">复制分享码</button>
                            <button id="load-share-code-btn">粘贴并加载</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>控制</h3>
                        <button id="reset-map-btn"
                            class="secondary">重置地图</button>
                        <div class="toggle-controls-wrapper">
                            <div class="toggle-switch">
                                <span class="label">调试视野</span>
                                <input type="checkbox" id="debug-vision-toggle">
                                <label for="debug-vision-toggle">Toggle</label>
                            </div>
                            <div id="dpad-toggle-container"
                                class="toggle-switch">
                                <span class="label">方向按键</span>
                                <input type="checkbox" id="dpad-toggle" checked>
                                <label for="dpad-toggle">Toggle</label>
                            </div>
                        </div>
                    </div>
                    <!-- === 新增历史记录控制 === -->
                    <div class="control-group">
                        <h3>历史记录</h3>
                        <div class="share-buttons-container">
                            <button id="undo-btn" class="secondary">撤回</button>
                            <button id="save-btn" class="secondary">存档</button>
                            <button id="rewind-btn"
                                class="secondary">回溯</button>
                        </div>
                    </div>
                    <!-- === 新增结束 === -->
                    <div class="control-group">
                        <h3>编辑器</h3>
                        <button id="edit-map-btn">编辑地图</button>
                    </div>
                </div>

                <!-- Editor Mode UI -->
                <div id="editor-controls" style="display: none;">
                    <div class="control-group">
                        <h3>编辑器工具</h3>
                        <div class="editor-toolbar">
                            <button id="tool-wall"
                                class="tool-btn active">墙壁</button>
                            <button id="tool-door" class="tool-btn">门</button>
                            <button id="tool-lock" class="tool-btn">锁</button>
                            <button id="tool-key" class="tool-btn">钥匙</button>
                            <button id="tool-end" class="tool-btn">终点</button>
                            <button id="tool-ghost" class="tool-btn">鬼</button>
                            <button id="tool-eraser"
                                class="tool-btn">橡皮擦</button>
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>地图选项</h3>
                        <label class="label">游戏模式</label>
                        <div class="mode-selector">
                            <button id="editor-mode-exploration-btn"
                                class="mode-btn active">探索模式</button>
                            <button id="editor-mode-death-loop-btn"
                                class="mode-btn">死亡循环</button>
                        </div>
                        <div class="inline-control-group">
                            <label for="editor-map-size-input">地图大小
                                (8-20):</label>
                            <input type="number" id="editor-map-size-input"
                                value="10" min="8" max="20">
                        </div>
                        <div id="initial-health-container"
                            class="inline-control-group">
                            <label for="editor-initial-health">初始生命:</label>
                            <input type="number" id="editor-initial-health"
                                value="5" min="1">
                        </div>
                        <div id="initial-stamina-container"
                            class="inline-control-group" style="display: none;">
                            <label for="editor-initial-stamina">初始体力:</label>
                            <input type="number" id="editor-initial-stamina"
                                value="100" min="1">
                        </div>
                    </div>
                    <div class="control-group">
                        <h3>控制</h3>
                        <button id="play-edited-map-btn">游玩地图</button>
                        <button id="clear-map-btn" class="danger">清空地图</button>
                    </div>
                    <div class="control-group">
                        <h3>分享</h3>
                        <div class="share-buttons-container">
                            <button
                                id="editor-copy-share-code-btn">复制分享码</button>
                            <button
                                id="editor-load-share-code-btn">粘贴并加载</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Overlays -->
        <div id="death-overlay" class="overlay">
            <div class="overlay-content">
                <h2 id="death-message">你死了</h2>
                <div class="buttons">
                    <button id="revive-btn">复活</button>
                </div>
            </div>
        </div>

        <div id="game-over-overlay" class="overlay">
            <div class="overlay-content">
                <h2>你死了，游戏结束</h2>
                <div class="buttons">
                    <button id="game-over-replay-btn">再次游玩该地图</button>
                    <button id="game-over-new-map-btn">游玩新地图</button>
                </div>
            </div>
        </div>

        <div id="win-overlay" class="overlay">
            <div class="overlay-content">
                <h2>你赢了！</h2>
                <p id="win-stats"></p>
                <div class="buttons">
                    <button id="win-replay-btn">再次游玩该地图</button>
                    <button id="win-new-map-btn">游玩新地图</button>
                </div>
            </div>
        </div>

        <!-- Custom Confirm Overlay -->
        <div id="confirm-overlay" class="overlay">
            <div class="overlay-content">
                <p id="confirm-message">你确定吗？</p>
                <div class="buttons">
                    <button id="confirm-yes-btn" class="danger">确认</button>
                    <button id="confirm-no-btn" class="secondary">取消</button>
                </div>
            </div>
        </div>

        <!-- Toast Notification -->
        <div id="toast-notification" class="toast"></div>
        <script
            src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
        <script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');

        class GhostMazeGame {
            constructor() {
                // DOM Elements
                this.healthDisplay = document.getElementById('player-health-display');
                this.keysDisplay = document.getElementById('player-keys-display');
                this.stepsDisplay = document.getElementById('player-steps-display');
                this.ghostProximityDisplay = document.getElementById('ghost-proximity-display');
                this.mapSizeInput = document.getElementById('map-size-input');
                this.editorMapSizeInput = document.getElementById('editor-map-size-input');
                this.toastElement = document.getElementById('toast-notification');
                this.confirmOverlay = document.getElementById('confirm-overlay');
                this.confirmMessage = document.getElementById('confirm-message');
                this.confirmYesBtn = document.getElementById('confirm-yes-btn');
                this.confirmNoBtn = document.getElementById('confirm-no-btn');
                this.toastTimeout = null;
                this.animationFrameId = null;
                this.autoMoveInterval = null;
                this.dpadInterval = null;
                
                const computedStyle = getComputedStyle(document.documentElement);
                this.colors = {
                    ground: computedStyle.getPropertyValue('--ground-color').trim(),
                    gridLine: computedStyle.getPropertyValue('--grid-line-color').trim(),
                    unexplored: computedStyle.getPropertyValue('--unexplored-color').trim(),
                    wall: computedStyle.getPropertyValue('--wall-color').trim(),
                    player: computedStyle.getPropertyValue('--player-color').trim(),
                    ghost: computedStyle.getPropertyValue('--ghost-color').trim(),
                    endPoint: computedStyle.getPropertyValue('--end-point-color').trim(),
                    key: computedStyle.getPropertyValue('--key-color').trim(),
                    startRoomHighlight: computedStyle.getPropertyValue('--start-room-highlight').trim(),
                    hoverHighlight: computedStyle.getPropertyValue('--hover-highlight-color').trim()
                };
                
                // Game State
                this.state = 'menu';
                this.gameMode = 'exploration'; // 'exploration' or 'death-loop'
                this.initialHealth = 5;
                this.initialStamina = 100;
                this.loopCount = 0;
                this.width = 10;
                this.height = 10;
                this.cellSize = canvas.width / this.width;
                this.mapData = null;

                // Player
                this.player = { x: 1, y: 1, hp: 5, stamina: 100, trail: [], keys: 0 , steps: 0};

                // Ghosts & Items
                this.ghosts = [];
                this.ghostCount = 3;
                this.items = [];

                // Map data structures
                this.hWalls = [];
                this.vWalls = [];
                this.startPos = { x: 1, y: 1 };
                this.endPos = { x: 0, y: 0 };
                
                // Visibility
                this.seenCells = [];
                this.debugVision = false;

                // Editor State
                this.editor = {
                    active: false,
                    tool: 'wall',
                    isDragging: false,
                    didDrag: false,
                    dragAxis: null,
                    lastDragPos: null,
                    hoveredWall: null
                };

                // === 新增: 历史记录系统状态 ===
                this.history = [];       // 存储所有状态快照
                this.checkpoints = [];   // 存储存档点的步数索引
                this.currentStep = -1;   // 指向当前状态在 history 数组中的索引
                // === 新增结束 ===

                this.dpad = {
                    element: document.getElementById('dpad-controls'),
                    grip: document.getElementById('dpad-grip'),
                    isDragging: false,
                    isResizing: false,
                    startX: 0,
                    startY: 0,
                    initialLeft: 0,
                    initialTop: 0,
                    initialDist: 0,
                    currentScale: 1
                };

                this.bindUI();
                this.showInitialMessage();
            }
            
            showInitialMessage() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = 'black';
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('点击 "随机生成新地图" 或加载分享码开始游戏', canvas.width / 2, canvas.height / 2);
            }

            // ==================================================
            //  UI BINDING & CONTROLS
            // ==================================================
            bindUI() {
                document.getElementById('generate-map-btn').addEventListener('click', () => this.generateNewRandomMap());
                
                // --- 分享功能绑定 (已最终修正) ---
                // 主界面：“复制分享码”按钮 -> copyShareCode()
                document.getElementById('copy-share-code-btn').addEventListener('click', () => this.copyShareCode());
                // 主界面：“粘贴并加载”按钮 -> loadFromShareCode()
                document.getElementById('load-share-code-btn').addEventListener('click', async () => {
                    try {
                        const code = await navigator.clipboard.readText();
                        if (code) { this.loadFromShareCode(code); } 
                        else { this.showToast('剪贴板为空。', 3000, 'error'); }
                    } catch (err) {
                        console.error('无法读取剪贴板内容: ', err);
                        this.showToast('无法读取剪贴板。请检查浏览器权限。', 3000, 'error');
                    }
                });

                // 编辑器：“复制分享码”按钮 -> copyShareCode(true)
                document.getElementById('editor-copy-share-code-btn').addEventListener('click', () => this.copyShareCode(true));
                // 编辑器：“粘贴并加载”按钮 -> loadFromShareCode(true)
                document.getElementById('editor-load-share-code-btn').addEventListener('click', async () => {
                    try {
                        const code = await navigator.clipboard.readText();
                        if (code) { this.loadFromShareCode(code, true); } 
                        else { this.showToast('剪贴板为空。', 3000, 'error'); }
                    } catch (err) {
                        console.error('无法读取剪贴板内容: ', err);
                        this.showToast('无法读取剪贴板。请检查浏览器权限。', 3000, 'error');
                    }
                });
                // --- 分享功能绑定结束 ---

                document.getElementById('reset-map-btn').addEventListener('click', () => this.resetCurrentMap());
                document.getElementById('debug-vision-toggle').addEventListener('change', (e) => {
                    this.debugVision = e.target.checked;
                    this.draw();
                    if (this.state === 'playing') {
                        this.updateProximityWarning();
                    }
                });
                document.getElementById('edit-map-btn').addEventListener('click', () => this.enterEditorMode());

                // Mode Selection Buttons
                document.getElementById('mode-exploration-btn').addEventListener('click', () => this.setGameMode('exploration'));
                document.getElementById('mode-death-loop-btn').addEventListener('click', () => this.setGameMode('death-loop'));
                document.getElementById('editor-mode-exploration-btn').addEventListener('click', () => this.setGameMode('exploration', true));
                document.getElementById('editor-mode-death-loop-btn').addEventListener('click', () => this.setGameMode('death-loop', true));

                document.getElementById('revive-btn').addEventListener('click', () => this.revivePlayer());
                document.getElementById('game-over-replay-btn').addEventListener('click', () => this.resetCurrentMap());
                document.getElementById('game-over-new-map-btn').addEventListener('click', () => this.generateNewRandomMap());
                document.getElementById('win-replay-btn').addEventListener('click', () => this.resetCurrentMap());
                document.getElementById('win-new-map-btn').addEventListener('click', () => this.generateNewRandomMap());

                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.setEditorTool(e.target.id.split('-')[1]));
                });
                this.editorMapSizeInput.addEventListener('change', () => this.resizeAndClearEditor());
                document.getElementById('play-edited-map-btn').addEventListener('click', () => this.playEditedMap());
                document.getElementById('clear-map-btn').addEventListener('click', () => this.clearEditorMap());
                
                window.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));
                canvas.addEventListener('mouseleave', (e) => this.handleCanvasMouseLeave(e));
                this.bindDpadControls();
                document.getElementById('dpad-toggle').addEventListener('change', (e) => {
                    this.updateDpadVisibility();
                });

                this.initializeDpadTouchControls();

                document.getElementById('undo-btn').addEventListener('click', () => this.handleUndo());
                document.getElementById('save-btn').addEventListener('click', () => this.handleSave());
                document.getElementById('rewind-btn').addEventListener('click', () => this.handleRewind());
            }

            initializeDpadTouchControls() {
                const dpad = this.dpad;

                // 1. 从 localStorage 加载并应用状态
                const savedLeft = localStorage.getItem('dpadLeft');
                const savedTop = localStorage.getItem('dpadTop');
                const savedScale = localStorage.getItem('dpadScale');

                if (savedScale) {
                    dpad.currentScale = parseFloat(savedScale);
                    dpad.element.style.transform = `scale(${dpad.currentScale})`;
                }

                if (savedLeft && savedTop) {
                    dpad.element.style.left = savedLeft;
                    dpad.element.style.top = savedTop;
                    dpad.element.style.right = 'auto';
                    dpad.element.style.bottom = 'auto';
                }

                // 辅助函数：确保元素使用JS定位
                const ensureJsPositioning = () => {
                    if (dpad.element.style.left === '' || dpad.element.style.top === '') {
                        const rect = dpad.element.getBoundingClientRect();
                        dpad.element.style.left = `${rect.left}px`;
                        dpad.element.style.top = `${rect.top}px`;
                        dpad.element.style.right = 'auto';
                        dpad.element.style.bottom = 'auto';
                    }
                };

                // 2. 绑定触摸事件
                // 2a. 在中心的把手上绑定【单指拖动】
                dpad.grip.addEventListener('touchstart', (e) => {
                    const touches = e.touches;
                    if (touches.length === 1) {
                        e.preventDefault();
                        ensureJsPositioning();
                        dpad.isDragging = true;
                        dpad.startX = touches[0].clientX;
                        dpad.startY = touches[0].clientY;
                        dpad.initialLeft = parseFloat(dpad.element.style.left);
                        dpad.initialTop = parseFloat(dpad.element.style.top);
                    }
                }, { passive: false });

                // 2b. 在整个方向键容器上绑定【双指缩放】
                dpad.element.addEventListener('touchstart', (e) => {
                    const touches = e.touches;
                    if (touches.length === 2) {
                        e.preventDefault();
                        ensureJsPositioning();
                        dpad.isResizing = true;
                        const dx = touches[0].clientX - touches[1].clientX;
                        const dy = touches[0].clientY - touches[1].clientY;
                        dpad.initialDist = Math.sqrt(dx * dx + dy * dy);
                    }
                }, { passive: false });


                document.addEventListener('touchmove', (e) => {
                    if (!dpad.isDragging && !dpad.isResizing) return;
                    e.preventDefault();
                    const touches = e.touches;

                    if (dpad.isDragging && touches.length === 1) {
                        const dx = touches[0].clientX - dpad.startX;
                        const dy = touches[0].clientY - dpad.startY;
                        dpad.element.style.left = `${dpad.initialLeft + dx}px`;
                        dpad.element.style.top = `${dpad.initialTop + dy}px`;
                    } else if (dpad.isResizing && touches.length === 2) {
                        const dx = touches[0].clientX - touches[1].clientX;
                        const dy = touches[0].clientY - touches[1].clientY;
                        const currentDist = Math.sqrt(dx * dx + dy * dy);
                        const scaleChange = currentDist / dpad.initialDist;
                        let newScale = dpad.currentScale * scaleChange;
                        newScale = Math.max(0.5, Math.min(2.5, newScale));
                        dpad.element.style.transform = `scale(${newScale})`;
                    }
                }, { passive: false });

                document.addEventListener('touchend', (e) => {
                    if (dpad.isResizing) {
                        const transformStyle = dpad.element.style.transform;
                        const scaleMatch = transformStyle.match(/scale\((.+)\)/);
                        if (scaleMatch) {
                            dpad.currentScale = parseFloat(scaleMatch[1]);
                        }
                        localStorage.setItem('dpadScale', dpad.currentScale);
                    }
                    
                    if (dpad.isDragging) {
                        localStorage.setItem('dpadLeft', dpad.element.style.left);
                        localStorage.setItem('dpadTop', dpad.element.style.top);
                    }

                    dpad.isDragging = false;
                    dpad.isResizing = false;
                });
            }

            setGameMode(newMode, fromEditor = false) {
                if (this.gameMode === newMode && !fromEditor) return;
                this.gameMode = newMode;

                const isExploration = newMode === 'exploration';

                // Toggle active class for main buttons
                document.getElementById('mode-exploration-btn').classList.toggle('active', isExploration);
                document.getElementById('mode-death-loop-btn').classList.toggle('active', !isExploration);

                // Toggle active class for editor buttons
                document.getElementById('editor-mode-exploration-btn').classList.toggle('active', isExploration);
                document.getElementById('editor-mode-death-loop-btn').classList.toggle('active', !isExploration);

                // Toggle visibility of status bars
                document.getElementById('status-bar-exploration').style.display = isExploration ? 'flex' : 'none';
                document.getElementById('status-bar-death-loop').style.display = isExploration ? 'none' : 'flex';

                // Toggle visibility of editor initial value inputs
                document.getElementById('initial-health-container').style.display = isExploration ? 'flex' : 'none';
                document.getElementById('initial-stamina-container').style.display = isExploration ? 'none' : 'flex';

                if (this.state !== 'menu' && this.state !== 'editor') {
                    this.resetCurrentMap();
                }
                this.updateUIDisplays();
            }

            updateDpadVisibility() {
                const dpadToggle = document.getElementById('dpad-toggle');
                const dpadControls = document.getElementById('dpad-controls');
                const shouldShow = dpadToggle.checked && !this.editor.active;

                if (shouldShow) {
                    dpadControls.classList.remove('hidden');
                } else {
                    dpadControls.classList.add('hidden');
                }
            }

            bindDpadControls() {
                const upBtn = document.getElementById('dpad-up');
                const downBtn = document.getElementById('dpad-down');
                const leftBtn = document.getElementById('dpad-left');
                const rightBtn = document.getElementById('dpad-right');

                const handleDpadPress = (dx, dy) => {
                    if (this.state !== 'playing') return;
                    clearInterval(this.autoMoveInterval);
                    clearInterval(this.dpadInterval);
                    this.movePlayer(dx, dy);
                    this.dpadInterval = setInterval(() => {
                        this.movePlayer(dx, dy);
                    }, 200);
                };

                const handleDpadRelease = () => {
                    clearInterval(this.dpadInterval);
                };

                const addListeners = (element, dx, dy) => {
                    element.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleDpadPress(dx, dy);
                    });
                    element.addEventListener('mousedown', () => handleDpadPress(dx, dy));
                };

                addListeners(upBtn, 0, -1);
                addListeners(downBtn, 0, 1);
                addListeners(leftBtn, -1, 0);
                addListeners(rightBtn, 1, 0);

                document.addEventListener('touchend', handleDpadRelease);
                document.addEventListener('mouseup', handleDpadRelease);
            }

            // ==================================================
            //  CUSTOM NOTIFICATIONS & ANIMATION
            // ==================================================
            showToast(message, duration = 3000, type = 'info') {
                // 1. 清除任何正在进行的“隐藏”计时器
                clearTimeout(this.toastTimeout);

                // 2. 立即隐藏当前的 toast，为重新播放动画做准备
                this.toastElement.classList.remove('show');

                // 3. 使用一个非常短的延时 (setTimeout)
                // 这给浏览器足够的时间来处理 class 的移除操作
                // 然后再更新内容并重新显示，从而强制动画重新播放
                setTimeout(() => {
                    this.toastElement.textContent = message;
                    // 重置 class，移除旧的 success/error 等状态
                    this.toastElement.className = 'toast'; 
                    if (type !== 'info') {
                        this.toastElement.classList.add(type);
                    }
                    // 重新添加 'show' 类，触发进入动画
                    this.toastElement.classList.add('show');

                    // 4. 设置新的计时器，在指定时间后隐藏这个新的 toast
                    this.toastTimeout = setTimeout(() => {
                        this.toastElement.classList.remove('show');
                    }, duration);
                }, 100); // 100毫秒的延时足以产生一个清晰的“刷新”效果
            }

            showConfirm(message, onConfirm) {
                this.confirmMessage.textContent = message;
                this.confirmOverlay.style.display = 'flex';

                const hide = () => {
                    this.confirmOverlay.style.display = 'none';
                    this.confirmYesBtn.onclick = null;
                    this.confirmNoBtn.onclick = null;
                };

                this.confirmYesBtn.onclick = () => {
                    hide();
                    onConfirm();
                };
                this.confirmNoBtn.onclick = hide;
            }

            startAnimationLoop() {
                if (this.animationFrameId) return;
                const trailLifetime = 500;

                const loop = () => {
                    const now = Date.now();
                    
                    this.player.trail = this.player.trail.filter(p => now - p.timestamp < trailLifetime);
                    this.ghosts.forEach(g => {
                        g.trail = g.trail.filter(p => now - p.timestamp < trailLifetime);
                    });

                    if (this.state === 'playing') {
                        this.draw();
                        this.animationFrameId = requestAnimationFrame(loop);
                    } else {
                        this.stopAnimationLoop();
                    }
                };
                this.animationFrameId = requestAnimationFrame(loop);
            }

            stopAnimationLoop() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                }
            }

            // ==================================================
            //  GAME INITIALIZATION & STATE MANAGEMENT
            // ==================================================
            
            startGame(mapData) {
                this.stopAnimationLoop();
                this.mapData = JSON.parse(JSON.stringify(mapData));
                this.state = 'playing';

                this.history = [];
                this.checkpoints = [];
                this.currentStep = -1;
                
                this.width = mapData.width;
                this.height = mapData.height;
                this.cellSize = canvas.width / this.width;
                
                this.hWalls = mapData.hWalls;
                this.vWalls = mapData.vWalls;
                this.endPos = mapData.endPos;
                this.items = mapData.items || [];
                
                this.player = { x: 1, y: this.height - 2, trail: [], keys: 0 ,steps: 0 };
                if (this.gameMode === 'exploration') {
                    this.player.hp = this.initialHealth;
                } else {
                    this.player.stamina = this.initialStamina;
                    this.loopCount = 0;
                }
                
                this.ghosts = JSON.parse(JSON.stringify(mapData.initialGhosts));
                this.ghosts.forEach(g => g.trail = []);
                
                // Only reset seenCells if it's a truly new map start, not a death loop revival
                if (this.gameMode === 'exploration' || this.loopCount === 0) {
                    this.seenCells = Array(this.height).fill(null).map(() => Array(this.width).fill(false));
                }
                this.updateVisibility();
                
                this.updateUIDisplays();
                this.hideAllOverlays();
                this.startAnimationLoop();

                this.recordHistory();
            }

            generateNewRandomMap() {
                const size = parseInt(this.mapSizeInput.value);
                if (size < 8 || size > 20) {
                    this.showToast('地图大小必须在 8 到 20 之间。', 3000, 'error');
                    return;
                }
                // Per user request, random maps always use default values
                this.initialHealth = 5;
                this.initialStamina = 100;
                const mapData = this.generateMaze(size, size);
                this.startGame(mapData);
            }
            
            resetCurrentMap() {
                if (!this.mapData) {
                    this.showToast("没有可重置的地图。请先生成一个新地图。", 3000, 'error');
                    return;
                }
                this.startGame(this.mapData);
            }

            // ==================================================
            //  MAP GENERATION
            // ==================================================

            generateMaze(width, height) {
                this.width = width;
                this.height = height;
                this.cellSize = canvas.width / this.width;

                const wall = () => ({ type: 1, keys: 0 });
                const empty = () => ({ type: 0, keys: 0 });
                const door = () => ({ type: 2, keys: 0 });

                this.hWalls = Array(height + 1).fill(null).map(() => Array(width).fill(null).map(wall));
                this.vWalls = Array(height).fill(null).map(() => Array(width + 1).fill(null).map(wall));

                const roomY = height - 3;
                for (let y = roomY; y < roomY + 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        if (x < 2) this.vWalls[y][x + 1] = empty();
                        if (y < roomY + 2) this.hWalls[y + 1][x] = empty();
                    }
                }
                this.vWalls[roomY + 1][3] = door();
                this.hWalls[roomY][1] = door();
                
                this.startPos = { x: 1, y: height - 2 };

                const visited = Array(height).fill(null).map(() => Array(width).fill(false));
                for (let y = roomY; y < roomY + 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        visited[y][x] = true;
                    }
                }
                
                const stack = [];
                let startGenX, startGenY;
                do {
                    startGenX = Math.floor(Math.random() * width);
                    startGenY = Math.floor(Math.random() * height);
                } while (visited[startGenY][startGenX]);

                stack.push({ x: startGenX, y: startGenY });
                visited[startGenY][startGenX] = true;

                while (stack.length > 0) {
                    const current = stack.pop();
                    const neighbors = [];
                    const dirs = [{x:0, y:-1}, {x:1, y:0}, {x:0, y:1}, {x:-1, y:0}];
                    for (const dir of dirs) {
                        const nx = current.x + dir.x;
                        const ny = current.y + dir.y;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height && !visited[ny][nx]) {
                            neighbors.push({ x: nx, y: ny, dir: dir });
                        }
                    }

                    if (neighbors.length > 0) {
                        stack.push(current);
                        const { x: nx, y: ny, dir } = neighbors[Math.floor(Math.random() * neighbors.length)];
                        if (dir.x === 1) this.vWalls[current.y][current.x + 1] = empty();
                        else if (dir.x === -1) this.vWalls[current.y][current.x] = empty();
                        else if (dir.y === 1) this.hWalls[current.y + 1][current.x] = empty();
                        else if (dir.y === -1) this.hWalls[current.y][current.x] = empty();
                        visited[ny][nx] = true;
                        stack.push({ x: nx, y: ny });
                    }
                }
                
                const wallsToRemove = Math.floor(width * height * 0.08);
                let removedCount = 0;
                let attempts = 0;
                while (removedCount < wallsToRemove && attempts < wallsToRemove * 10) {
                    attempts++;
                    const rx = Math.floor(Math.random() * (width - 1));
                    const ry = Math.floor(Math.random() * (height - 1));

                    if (Math.random() > 0.5) {
                        if (rx < width - 1 && !(ry >= roomY && ry < roomY + 3 && rx + 1 === 3)) {
                            if (this.vWalls[ry][rx + 1].type === 1) {
                                this.vWalls[ry][rx + 1] = empty();
                                removedCount++;
                            }
                        }
                    } else {
                        if (ry < height - 1 && !(rx >= 0 && rx < 3 && ry + 1 === roomY)) {
                             if (this.hWalls[ry + 1][rx].type === 1) {
                                this.hWalls[ry + 1][rx] = empty();
                                removedCount++;
                            }
                        }
                    }
                }

                this.endPos = this.findFarthestEndCell();

                const doorProbability = 0.02;
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        const isNearEnd = (Math.abs(x - this.endPos.x) <= 1 && y === this.endPos.y) || (x === this.endPos.x && Math.abs(y - this.endPos.y) <= 1);
                        if (y < this.height - 1 && !this.isPosInStartRoom(x, y) && !this.isPosInStartRoom(x, y + 1) && !isNearEnd && Math.random() < doorProbability) this.hWalls[y + 1][x] = door();
                        if (x < width - 1 && !this.isPosInStartRoom(x, y) && !this.isPosInStartRoom(x + 1, y) && !isNearEnd && Math.random() < doorProbability) this.vWalls[y][x + 1] = door();
                    }
                }

                const {x: ex, y: ey} = this.endPos;
                if (this.hWalls[ey][ex].type === 0) this.hWalls[ey][ex] = { type: 3, keys: 3 };
                else if (this.hWalls[ey + 1][ex].type === 0) this.hWalls[ey + 1][ex] = { type: 3, keys: 3 };
                else if (this.vWalls[ey][ex].type === 0) this.vWalls[ey][ex] = { type: 3, keys: 3 };
                else if (this.vWalls[ey][ex + 1].type === 0) this.vWalls[ey][ex + 1] = { type: 3, keys: 3 };

                const occupied = new Set();
                occupied.add(`${this.endPos.x},${this.endPos.y}`);
                for (let y = height - 3; y < height; y++) {
                    for (let x = 0; x < 3; x++) {
                        occupied.add(`${x},${y}`);
                    }
                }

                const initialGhosts = [];
                while (initialGhosts.length < this.ghostCount) {
                    const x = Math.floor(Math.random() * width);
                    const y = Math.floor(Math.random() * height);
                    const posKey = `${x},${y}`;
                    if (!occupied.has(posKey)) {
                        initialGhosts.push({ x, y, id: initialGhosts.length });
                        occupied.add(posKey);
                    }
                }

                this.items = [];
                const keysToPlace = 4;
                const validCells = [];
                const preferredCells = [];
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (!occupied.has(`${x},${y}`)) {
                            validCells.push({x, y});
                            let wallCount = 0;
                            if (this.hWalls[y][x].type > 0) wallCount++;
                            if (this.hWalls[y + 1][x].type > 0) wallCount++;
                            if (this.vWalls[y][x].type > 0) wallCount++;
                            if (this.vWalls[y][x + 1].type > 0) wallCount++;
                            if (wallCount >= 3) {
                                preferredCells.push({x, y});
                            }
                        }
                    }
                }

                for (let i = 0; i < keysToPlace; i++) {
                    let pos = null;
                    if (preferredCells.length > 0) {
                        const index = Math.floor(Math.random() * preferredCells.length);
                        pos = preferredCells.splice(index, 1)[0];
                    } else if (validCells.length > 0) {
                        const index = Math.floor(Math.random() * validCells.length);
                        pos = validCells.splice(index, 1)[0];
                    }
                    if (pos) {
                        this.items.push({ x: pos.x, y: pos.y, type: 'key' });
                        const validIndex = validCells.findIndex(c => c.x === pos.x && c.y === pos.y);
                        if (validIndex > -1) validCells.splice(validIndex, 1);
                    }
                }

                return {
                    width, height,
                    hWalls: this.hWalls, vWalls: this.vWalls,
                    endPos: this.endPos, initialGhosts: initialGhosts, items: this.items
                };
            }
            
            findFarthestEndCell() {
                const distances = this.calculateDistances(this.startPos);
                let maxDist = -1;
                let farthestCell = null;

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (x === 0 || x === this.width - 1 || y === 0 || y === this.height - 1) {
                            let wallCount = 0;
                            if (this.hWalls[y][x].type > 0) wallCount++;
                            if (this.hWalls[y + 1][x].type > 0) wallCount++;
                            if (this.vWalls[y][x].type > 0) wallCount++;
                            if (this.vWalls[y][x + 1].type > 0) wallCount++;
                            
                            if (wallCount >= 3) {
                                if (distances[y][x] > maxDist) {
                                    maxDist = distances[y][x];
                                    farthestCell = { x, y };
                                }
                            }
                        }
                    }
                }
                return farthestCell || { x: this.width - 1, y: 0 };
            }

            // ==================================================
            //  PLAYER LOGIC
            // ==================================================
            handleKeyPress(e) {
                if (this.state !== 'playing') return;
                this.stopAutoMove();

                let dx = 0, dy = 0;
                switch (e.key) {
                    case 'ArrowUp': case 'w': dy = -1; break;
                    case 'ArrowDown': case 's': dy = 1; break;
                    case 'ArrowLeft': case 'a': dx = -1; break;
                    case 'ArrowRight': case 'd': dx = 1; break;
                    default: return;
                }
                e.preventDefault();
                this.movePlayer(dx, dy);
            }

            movePlayer(dx, dy) {
                if (this.state !== 'playing') return;

                const playerPrevPos = { x: this.player.x, y: this.player.y };
                const newX = this.player.x + dx;
                const newY = this.player.y + dy;

                if (newX < 0 || newX >= this.width || newY < 0 || newY >= this.height) return;

                let wall;
                if (dx === 1) wall = this.vWalls[this.player.y][this.player.x + 1];
                if (dx === -1) wall = this.vWalls[this.player.y][this.player.x];
                if (dy === 1) wall = this.hWalls[this.player.y + 1][this.player.x];
                if (dy === -1) wall = this.hWalls[this.player.y][this.player.x];

                if (wall) {
                    if (wall.type === 1) return;
                    if (wall.type === 3 && this.player.keys < wall.keys) return;
                    if (wall.type === 3 && this.player.keys >= wall.keys) {
                        wall.type = 0;
                    }
                }

                this.player.trail.unshift({ x: this.player.x, y: this.player.y, timestamp: Date.now() });

                // --- 玩家移动 ---
                this.player.x = newX;
                this.player.y = newY;
                this.player.steps++;
                
                if (this.gameMode === 'death-loop') {
                    this.player.stamina--;
                }
                
                this.updateUIDisplays();               
                this.updateVisibility();
                this.checkItemPickup();

                // 胜利判定优先于所有死亡判定
                if (this.player.x === this.endPos.x && this.player.y === this.endPos.y) {
                    this.handleWin();
                    return;
                }

                // 死亡判定 1: 体力耗尽
                if (this.gameMode === 'death-loop' && this.player.stamina <= 0) {
                    this.handlePlayerDeath('stamina_depleted');
                    return;
                }

                // 死亡判定 2: 检查玩家移动后是否撞上（静止的）鬼
                if (this.checkCollisionWithGhosts()) {
                    this.handlePlayerDeath('ghost');
                    return;
                }

                // --- 鬼魂移动 ---
                this.moveGhosts(playerPrevPos);

                // 死亡判定 3: 检查鬼魂移动后是否撞上玩家
                if (this.checkCollisionWithGhosts()) {
                    this.handlePlayerDeath('ghost');
                    return;
                }
                
                // --- 回合结束 ---
                this.updateProximityWarning();
                if (!this.animationFrameId) this.draw();

                this.recordHistory();
            }

            checkItemPickup() {
                const itemIndex = this.items.findIndex(item => item.x === this.player.x && item.y === this.player.y);
                if (itemIndex > -1) {
                    const item = this.items[itemIndex];
                    if (item.type === 'key') {
                        this.player.keys++;
                        this.showToast(`钥匙+1 (现在持有${this.player.keys}个)`, 2000, 'success');
                    }
                    this.items.splice(itemIndex, 1);
                    this.updateUIDisplays();
                }
            }
            
            resetPlayerPos() {
                this.player.x = this.startPos.x;
                this.player.y = this.height - 2;
                this.player.trail = [];
            }
            
            updateUIDisplays() {
                if (this.gameMode === 'exploration') {
                    this.healthDisplay.textContent = `生命: ${this.player.hp}`;
                    this.keysDisplay.textContent = `钥匙: ${this.player.keys}`;
                    this.stepsDisplay.textContent = `步数: ${this.player.steps}`;
                } else { // death-loop
                    document.getElementById('loop-count-display').textContent = `循环次数: ${this.loopCount}`;
                    document.getElementById('player-keys-display-death-loop').textContent = `钥匙: ${this.player.keys}`;
                    document.getElementById('player-stamina-display').textContent = `剩余体力: ${this.player.stamina}`;
                }
                this.updateProximityWarning();
            }

            updateProximityWarning() {
                if (this.gameMode === 'death-loop') {
                    document.body.classList.remove('danger-bg');
                    this.ghostProximityDisplay.classList.remove('warning');
                    return;
                }

                let totalNearbyGhosts = 0;
                let invisibleNearbyGhosts = 0;

                for (const ghost of this.ghosts) {
                    const isNearby = Math.abs(ghost.x - this.player.x) <= 1 && Math.abs(ghost.y - this.player.y) <= 1;
                    if (isNearby) {
                        totalNearbyGhosts++;
                        const isVisible = this.seenCells[ghost.y][ghost.x] || this.debugVision;
                        if (!isVisible) {
                            invisibleNearbyGhosts++;
                        }
                    }
                }

                this.ghostProximityDisplay.textContent = `周围鬼数: ${totalNearbyGhosts}`;

                if (invisibleNearbyGhosts > 0) {
                    document.body.classList.add('danger-bg');
                    this.ghostProximityDisplay.classList.add('warning');
                } else {
                    document.body.classList.remove('danger-bg');
                    this.ghostProximityDisplay.classList.remove('warning');
                }
            }

            // ==================================================
            //  GHOST LOGIC
            // ==================================================
            
            canGhostSeePlayer(ghost, playerPos) {
                if (!playerPos || ghost.x !== playerPos.x && ghost.y !== playerPos.y) return false;
                
                if (ghost.x === playerPos.x) {
                    const startY = Math.min(ghost.y, playerPos.y);
                    const endY = Math.max(ghost.y, playerPos.y);
                    for (let y = startY; y < endY; y++) {
                        if (this.hWalls[y + 1][ghost.x].type > 0) return false;
                    }
                } else {
                    const startX = Math.min(ghost.x, playerPos.x);
                    const endX = Math.max(ghost.x, playerPos.x);
                    for (let x = startX; x < endX; x++) {
                        if (this.vWalls[ghost.y][x + 1].type > 0) return false;
                    }
                }
                return true;
            }

            moveGhosts(playerPrevPos) {
                let moveIntents = [];

                // 阶段一：收集所有鬼的移动意图
                for (const ghost of this.ghosts) {
                    const sawBefore = this.canGhostSeePlayer(ghost, playerPrevPos);
                    const seesAfter = this.canGhostSeePlayer(ghost, this.player);

                    let target = null;
                    if (!sawBefore && seesAfter) target = this.player;
                    if (sawBefore && !seesAfter) target = playerPrevPos;
                    if (sawBefore && seesAfter) target = this.player;
                    
                    if (target) {
                        const path = this.findShortestPath(ghost, target);
                        if (path && path.length > 1) {
                            moveIntents.push({ ghost: ghost, nextStep: path[1] });
                        }
                    }
                }

                if (moveIntents.length === 0) return;

                // 阶段二：循环解析和执行，直到无法再取得进展
                // 增加一个循环次数上限，防止意外的死循环
                let maxIterations = this.ghosts.length + 1; 
                let madeProgress = true;

                while (madeProgress && moveIntents.length > 0 && maxIterations > 0) {
                    madeProgress = false;
                    maxIterations--;

                    // 获取所有当前被占据的格子
                    const occupiedCells = new Set(this.ghosts.map(g => `${g.x},${g.y}`));
                    
                    let possibleMoves = [];
                    let remainingIntents = [];

                    // 筛选出本轮所有理论上可行的移动（目标格子当前是空的）
                    for (const intent of moveIntents) {
                        const targetKey = `${intent.nextStep.x},${intent.nextStep.y}`;
                        if (!occupiedCells.has(targetKey)) {
                            possibleMoves.push(intent);
                        } else {
                            remainingIntents.push(intent);
                        }
                    }

                    // 解决“争抢同一个格子”的冲突
                    const finalMovesThisPass = [];
                    const claimedTargets = new Set();
                    for (const intent of possibleMoves) {
                        const targetKey = `${intent.nextStep.x},${intent.nextStep.y}`;
                        if (!claimedTargets.has(targetKey)) {
                            finalMovesThisPass.push(intent);
                            claimedTargets.add(targetKey);
                        } else {
                            // 这个移动因为冲突而失败，留到下一轮
                            remainingIntents.push(intent);
                        }
                    }

                    // 如果有可以成功移动的鬼，则执行移动
                    if (finalMovesThisPass.length > 0) {
                        for (const { ghost, nextStep } of finalMovesThisPass) {
                            ghost.trail.unshift({ x: ghost.x, y: ghost.y, timestamp: Date.now() });
                            ghost.x = nextStep.x;
                            ghost.y = nextStep.y;
                        }
                        madeProgress = true; // 标记本轮取得了进展
                    }
                    
                    // 更新意图列表，准备下一轮解析
                    moveIntents = remainingIntents;
                }
            }
            
            isCellOccupiedByGhost(x, y, selfId = -1) {
                return this.ghosts.some(g => g.id !== selfId && g.x === x && g.y === y);
            }

            // ==================================================
            //  GAME ENDING & OVERLAYS
            // ==================================================
            
            checkCollisionWithGhosts() {
                return this.ghosts.some(g => g.x === this.player.x && g.y === this.player.y);
            }

            handlePlayerDeath(reason = 'ghost') {
                this.stopAutoMove();
                this.stopAnimationLoop();
                this.state = 'dead';
                
                if (this.gameMode === 'exploration') {
                    this.player.hp--;
                    this.updateUIDisplays();
                    this.draw();
                    if (this.player.hp > 0) {
                        document.getElementById('death-message').textContent = `你死了 (剩余血量 ${this.player.hp})`;
                        document.getElementById('revive-btn').textContent = '复活';
                        document.getElementById('death-overlay').style.display = 'flex';
                    } else {
                        document.getElementById('game-over-overlay').style.display = 'flex';
                    }
                } else { // death-loop
                    this.draw();
                    const message = reason === 'stamina_depleted' ? '体力耗尽，你死了' : '你死了';
                    document.getElementById('death-message').textContent = message;
                    document.getElementById('revive-btn').textContent = '复活';
                    document.getElementById('death-overlay').style.display = 'flex';
                }
            }
            
            revivePlayer() {
                if (this.gameMode === 'exploration') {
                    this.resetPlayerPos();
                    this.state = 'playing';
                    this.hideAllOverlays();
                    this.updateVisibility();
                    this.updateProximityWarning();
                    this.startAnimationLoop();
                    this.recordHistory(true); 
                } else { // death-loop
                    this.loopCount++;
                    this.state = 'playing';
                    this.hideAllOverlays();

                    // 重置玩家和地图状态，但保留视野
                    this.resetPlayerPos(); // 此函数会正确重置 player.trail
                    this.player.keys = 0;
                    this.player.steps = 0;
                    this.player.stamina = this.initialStamina;
                    
                    // 从主地图数据重置物品和鬼魂
                    this.items = JSON.parse(JSON.stringify(this.mapData.items || []));
                    this.ghosts = JSON.parse(JSON.stringify(this.mapData.initialGhosts));
                    
                    // *** 关键修复：为新加载的鬼魂初始化 trail 数组，防止 draw() 函数崩溃 ***
                    this.ghosts.forEach(g => g.trail = []);

                    // 根据玩家复活后的新位置，更新视野数据
                    this.updateVisibility();
                    
                    // 更新UI上的状态显示
                    this.updateUIDisplays();

                    // 立即开始游戏循环，它会在下一帧自动重绘整个游戏画面
                    this.startAnimationLoop();
                    this.recordHistory(true);
                }
            }

            handleWin() {
                this.stopAutoMove();
                this.stopAnimationLoop();
                this.state = 'won';

                const winStats = document.getElementById('win-stats');
                if (this.gameMode === 'exploration') {
                    winStats.textContent = `你以 ${this.player.hp} 点剩余生命和 ${this.player.steps} 步的成绩通关！`;
                } else { // death-loop
                    winStats.textContent = `你以 ${this.loopCount} 次循环和 ${this.player.stamina} 点剩余体力的成绩通关！`;
                }

                document.getElementById('win-overlay').style.display = 'flex';
            }
            
            hideAllOverlays() {
                document.getElementById('death-overlay').style.display = 'none';
                document.getElementById('game-over-overlay').style.display = 'none';
                document.getElementById('win-overlay').style.display = 'none';
            }

            // ==================================================
            //  VISIBILITY
            // ==================================================
            updateVisibility() {
                const roomY = this.height - 3;
                for (let y = roomY; y < roomY + 3; y++) {
                    for (let x = 0; x < 3; x++) {
                        this.seenCells[y][x] = true;
                    }
                }

                const { x, y } = this.player;
                this.seenCells[y][x] = true;

                for (let i = x + 1; i < this.width; i++) {
                    if (this.vWalls[y][i].type > 0) break;
                    this.seenCells[y][i] = true;
                }
                for (let i = x - 1; i >= 0; i--) {
                    if (this.vWalls[y][i + 1].type > 0) break;
                    this.seenCells[y][i] = true;
                }
                for (let i = y + 1; i < this.height; i++) {
                    if (this.hWalls[i][x].type > 0) break;
                    this.seenCells[i][x] = true;
                }
                for (let i = y - 1; i >= 0; i--) {
                    if (this.hWalls[i + 1][x].type > 0) break;
                    this.seenCells[i][x] = true;
                }
            }

            // ==================================================
            //  DRAWING
            // ==================================================
            draw() {
                if (this.state === 'menu') return;
                if (this.editor.active) {
                    this.drawEditor();
                    return;
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const cs = this.cellSize;
                const now = Date.now();
                const trailLifetime = 500;
                const initialAlpha = 0.3;

                // --- 绘制底层元素 ---
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        ctx.fillStyle = this.colors.ground;
                        ctx.fillRect(x * cs, y * cs, cs, cs);
                    }
                }
                
                this.player.trail.forEach(p => {
                    if (this.seenCells[p.y][p.x] || this.debugVision) {
                        const age = now - p.timestamp;
                        const alpha = initialAlpha * (1 - age / trailLifetime);
                        this.drawCircle(p.x, p.y, this.colors.player, alpha);
                    }
                });
                this.ghosts.forEach(ghost => {
                    ghost.trail.forEach(p => {
                        if (this.seenCells[p.y][p.x] || this.debugVision) {
                            const age = now - p.timestamp;
                            const alpha = initialAlpha * (1 - age / trailLifetime);
                            this.drawCircle(p.x, p.y, this.colors.ghost, alpha);
                        }
                    });
                });

                ctx.strokeStyle = this.colors.gridLine;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i <= this.width; i++) {
                    const x = Math.round(i * cs) + 0.5;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.height * cs);
                }
                for (let i = 0; i <= this.height; i++) {
                    const y = Math.round(i * cs) + 0.5;
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.width * cs, y);
                }
                ctx.stroke();

                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (!this.seenCells[y][x] && !this.debugVision) {
                            ctx.fillStyle = this.colors.unexplored;
                            ctx.fillRect(x * cs, y * cs, cs, cs);
                        }
                    }
                }

                // --- 绘制中间层元素 (墙体和地面实体) ---
                ctx.beginPath();
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.seenCells[y][x] || this.debugVision) {
                            if (this.hWalls[y][x].type > 0) this.drawWallOrDoor(x * cs, y * cs, (x + 1) * cs, y * cs, this.hWalls[y][x]);
                            if (this.hWalls[y + 1][x].type > 0) this.drawWallOrDoor(x * cs, (y + 1) * cs, (x + 1) * cs, (y + 1) * cs, this.hWalls[y + 1][x]);
                            if (this.vWalls[y][x].type > 0) this.drawWallOrDoor(x * cs, y * cs, x * cs, (y + 1) * cs, this.vWalls[y][x]);
                            if (this.vWalls[y][x + 1].type > 0) this.drawWallOrDoor((x + 1) * cs, y * cs, (x + 1) * cs, (y + 1) * cs, this.vWalls[y][x + 1]);
                        }
                    }
                }
                ctx.stroke();

                if (this.endPos && (this.seenCells[this.endPos.y][this.endPos.x] || this.debugVision)) {
                    this.drawCircle(this.endPos.x, this.endPos.y, this.colors.endPoint);
                }

                // --- 绘制活动单位 (鬼和玩家) ---
                this.ghosts.forEach(ghost => {
                    if (this.seenCells[ghost.y][ghost.x] || this.debugVision) {
                        this.drawCircle(ghost.x, ghost.y, this.colors.ghost);
                    }
                });
                this.drawCircle(this.player.x, this.player.y, this.colors.player);
                
                // --- 绘制顶层元素 (覆盖在单位之上) ---
                // 绘制物品 (钥匙等)
                this.items.forEach(item => {
                    if (this.seenCells[item.y][item.x] || this.debugVision) {
                        this.drawItem(item);
                    }
                });

                // 最后绘制锁上的数字，确保它在最顶层
                this.drawLockNumbers(true);
            }

            drawWallOrDoor(x1, y1, x2, y2, wallObject, isHighlight = false) {
                const type = wallObject.type;
                if (isHighlight) {
                    ctx.strokeStyle = this.colors.hoverHighlight;
                    ctx.lineWidth = Math.max(3, this.cellSize / 8);
                } else {
                    ctx.strokeStyle = this.colors.wall;
                    ctx.lineWidth = (type === 3) ? Math.max(4, this.cellSize / 8) : Math.max(2, this.cellSize / 10);
                }
                
                if (type === 1 || type === 3) { // Wall or Lock
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                } else if (type === 2) { // Door
                    const isHorizontal = y1 === y2;
                    const length = isHorizontal ? x2 - x1 : y2 - y1;
                    const gap = length / 3;
                    if (isHorizontal) {
                        ctx.moveTo(x1, y1); ctx.lineTo(x1 + gap, y1);
                        ctx.moveTo(x2 - gap, y2); ctx.lineTo(x2, y2);
                    } else {
                        ctx.moveTo(x1, y1); ctx.lineTo(x1, y1 + gap);
                        ctx.moveTo(x2, y2 - gap); ctx.lineTo(x2, y2);
                    }
                }
            }

            drawLockNumbers(inGame = false) {
                const cs = this.cellSize;
                
                // 遍历所有内部的水平墙
                for (let y = 1; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.hWalls[y][x].type === 3) {
                            // 检查是否应该显示：不在游戏模式中，或开启调试视野，或墙两侧任一单元格可见
                            const isVisible = !inGame || this.debugVision || this.seenCells[y - 1][x] || this.seenCells[y][x];
                            if (isVisible) {
                                this.drawNumberOnWall(x * cs, y * cs, (x + 1) * cs, y * cs, this.hWalls[y][x].keys);
                            }
                        }
                    }
                }

                // 遍历所有内部的垂直墙
                for (let y = 0; y < this.height; y++) {
                    for (let x = 1; x < this.width; x++) {
                        if (this.vWalls[y][x].type === 3) {
                            // 检查是否应该显示：不在游戏模式中，或开启调试视野，或墙两侧任一单元格可见
                            const isVisible = !inGame || this.debugVision || this.seenCells[y][x - 1] || this.seenCells[y][x];
                            if (isVisible) {
                                this.drawNumberOnWall(x * cs, y * cs, x * cs, (y + 1) * cs, this.vWalls[y][x].keys);
                            }
                        }
                    }
                }
            }

            drawNumberOnWall(x1, y1, x2, y2, number) {
const centerX = (x1 + x2) / 2;
const centerY = (y1 + y2) / 2;
const fontSize = this.cellSize * 0.4;
const text = number.toString();
                ctx.font = `bold ${fontSize}px sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            // 设置描边样式
            ctx.strokeStyle = 'black'; // 描边颜色为黑色
            ctx.lineWidth = 3;         // 描边宽度

            // 1. 先绘制文字的描边
            ctx.strokeText(text, centerX, centerY);

            // 2. 再在同一位置绘制文字的填充颜色
            ctx.fillStyle = this.colors.key; // 填充颜色为黄色
            ctx.fillText(text, centerX, centerY);
        }

            drawCircle(x, y, color, alpha = 1.0) {
                if (alpha <= 0) return;
                const cs = this.cellSize;
                ctx.globalAlpha = alpha;
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x * cs + cs / 2, y * cs + cs / 2, cs * 0.35, 0, 2 * Math.PI);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            drawItem(item) {
                if (item.type === 'key') {
                    const cs = this.cellSize;
                    const centerX = item.x * cs + cs / 2;
                    const centerY = item.y * cs + cs / 2;
                    const size = cs * 0.3;
                    ctx.fillStyle = this.colors.key;
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY - size); // Top
                    ctx.lineTo(centerX + size, centerY); // Right
                    ctx.lineTo(centerX, centerY + size); // Bottom
                    ctx.lineTo(centerX - size, centerY); // Left
                    ctx.closePath();
                    ctx.fill();
                }
            }

            // ==================================================
            //  EDITOR LOGIC
            // ==================================================
            
            enterEditorMode() {
                this.stopAnimationLoop();
                if (!this.mapData) {
                    this.width = 10;
                    this.height = 10;
                    this.createBlankEditorMap();
                    this.mapData = {
                        width: this.width, height: this.height,
                        hWalls: JSON.parse(JSON.stringify(this.hWalls)),
                        vWalls: JSON.parse(JSON.stringify(this.vWalls)),
                        endPos: null,
                        initialGhosts: [],
                        items: []
                    };
                }

                this.state = 'editor';
                this.editor.active = true;
                this.setEditorTool('wall');
                
                document.getElementById('game-controls').style.display = 'none';
                document.getElementById('editor-controls').style.display = 'block';
                
                this.width = this.mapData.width;
                this.height = this.mapData.height;
                this.editorMapSizeInput.value = this.width;
                this.cellSize = canvas.width / this.width;
                this.hWalls = JSON.parse(JSON.stringify(this.mapData.hWalls));
                this.vWalls = JSON.parse(JSON.stringify(this.mapData.vWalls));
                this.endPos = this.mapData.endPos ? {...this.mapData.endPos} : null;
                this.ghosts = JSON.parse(JSON.stringify(this.mapData.initialGhosts || []));
                this.items = JSON.parse(JSON.stringify(this.mapData.items || []));
                
                this.drawEditor();
                this.updateDpadVisibility();
            }
            
            createBlankEditorMap() {
                this.cellSize = canvas.width / this.width;
                
                const wall = () => ({ type: 1, keys: 0 });
                const empty = () => ({ type: 0, keys: 0 });
                const door = () => ({ type: 2, keys: 0 });

                this.hWalls = Array(this.height + 1).fill(null).map(() => Array(this.width).fill(null).map(empty));
                this.vWalls = Array(this.height).fill(null).map(() => Array(this.width + 1).fill(null).map(empty));
                
                for (let x = 0; x < this.width; x++) {
                    this.hWalls[0][x] = wall();
                    this.hWalls[this.height][x] = wall();
                }
                for (let y = 0; y < this.height; y++) {
                    this.vWalls[y][0] = wall();
                    this.vWalls[y][this.width] = wall();
                }
                
                const roomY = this.height - 3;
                for (let x = 0; x < 3; x++) this.hWalls[roomY + 3][x] = wall();
                for (let y = roomY; y < roomY + 3; y++) this.vWalls[y][0] = wall();
                this.hWalls[roomY][0] = wall(); this.hWalls[roomY][2] = wall();
                this.vWalls[roomY][3] = wall(); this.vWalls[roomY+2][3] = wall();
                this.hWalls[roomY][1] = door();
                this.vWalls[roomY+1][3] = door();
                
                this.startPos = { x: 1, y: this.height - 2 };
                this.endPos = null;
                this.ghosts = [];
                this.items = [];
            }

            resizeAndClearEditor() {
                const size = parseInt(this.editorMapSizeInput.value);
                if (size < 8 || size > 20) {
                    this.showToast('地图大小必须在 8 到 20 之间。', 3000, 'error');
                    this.editorMapSizeInput.value = this.width;
                    return;
                }
                this.width = size;
                this.height = size;
                this.createBlankEditorMap();
                this.drawEditor();
            }
            
            playEditedMap() {
                // if (!this.endPos) {
                //     this.showToast('请在地图上放置一个终点。', 3000, 'error');
                //     return;
                // }
                
                this.editor.active = false;
                document.getElementById('game-controls').style.display = 'block';
                document.getElementById('editor-controls').style.display = 'none';
                
                this.initialHealth = parseInt(document.getElementById('editor-initial-health').value) || 5;
                this.initialStamina = parseInt(document.getElementById('editor-initial-stamina').value) || 100;

                const editedMapData = {
                    width: this.width, height: this.height,
                    hWalls: this.hWalls, vWalls: this.vWalls,
                    endPos: this.endPos,
                    initialGhosts: this.ghosts.map((g, i) => ({x: g.x, y: g.y, id: i})),
                    items: this.items
                };
                
                this.startGame(editedMapData);
                this.updateDpadVisibility(); 
            }
            
            clearEditorMap() {
                this.showConfirm('你确定要清空所有墙壁、实体和物品吗？', () => {
                    this.createBlankEditorMap();
                    this.drawEditor();
                });
            }
            
            setEditorTool(tool) {
                this.editor.tool = tool;
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.id === `tool-${tool}`);
                });
                this.editor.hoveredWall = null;
                this.drawEditor();
            }
            
            drawEditor() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                const cs = this.cellSize;

                ctx.fillStyle = this.colors.ground;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = this.colors.startRoomHighlight;
                ctx.fillRect(0, (this.height - 3) * cs, 3 * cs, 3 * cs);

                ctx.strokeStyle = this.colors.gridLine;
                ctx.lineWidth = 1;
                ctx.beginPath();
                for (let i = 0; i <= this.width; i++) {
                    const x = Math.round(i * cs) + 0.5;
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.height * cs);
                }
                for (let i = 0; i <= this.height; i++) {
                    const y = Math.round(i * cs) + 0.5;
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.width * cs, y);
                }
                ctx.stroke();
                
                ctx.beginPath();
                for (let y = 0; y <= this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        if (this.hWalls[y][x].type > 0) {
                            this.drawWallOrDoor(x * cs, y * cs, (x + 1) * cs, y * cs, this.hWalls[y][x]);
                        }
                    }
                }
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x <= this.width; x++) {
                        if (this.vWalls[y][x].type > 0) {
                            this.drawWallOrDoor(x * cs, y * cs, x * cs, (y + 1) * cs, this.vWalls[y][x]);
                        }
                    }
                }
                ctx.stroke();
                this.drawLockNumbers();
                
                if (this.editor.hoveredWall && !this.editor.isDragging) {
                    ctx.beginPath();
                    const {x, y, type} = this.editor.hoveredWall;
                    const wallType = this.editor.tool === 'door' ? 2 : (this.editor.tool === 'lock' ? 3 : 1);
                    if (type === 'h') {
                        this.drawWallOrDoor(x * cs, y * cs, (x + 1) * cs, y * cs, {type: wallType, keys: '?'}, true);
                    } else {
                        this.drawWallOrDoor(x * cs, y * cs, x * cs, (y + 1) * cs, {type: wallType, keys: '?'}, true);
                    }
                    ctx.stroke();
                }

                this.items.forEach(item => this.drawItem(item));
                if (this.endPos) this.drawCircle(this.endPos.x, this.endPos.y, this.colors.endPoint);
                this.ghosts.forEach(g => this.drawCircle(g.x, g.y, this.colors.ghost));
                this.drawCircle(this.startPos.x, this.startPos.y, this.colors.player);
            }
            
            // Editor Mouse Handlers
            getMousePos(e) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            }
            
            isPosInStartRoom(cellX, cellY) {
                const roomY = this.height - 3;
                return cellX >= 0 && cellX < 3 && cellY >= roomY && cellY < roomY + 3;
            }
            
            isWallEditable(wall) {
                if (!wall) return false;
                const {x, y, type} = wall;
                
                if (type === 'h' && (y === 0 || y === this.height)) return false;
                if (type === 'v' && (x === 0 || x === this.width)) return false;
                
                const roomY = this.height - 3;
                if (type === 'h' && y === roomY && x >= 0 && x < 3) return false;
                if (type === 'h' && y === roomY + 3 && x >= 0 && x < 3) return false;
                if (type === 'v' && x === 0 && y >= roomY && y < roomY + 3) return false;
                if (type === 'v' && x === 3 && y >= roomY && y < roomY + 3) return false;
                
                if (x >= 0 && x < 3 && y > roomY && y < roomY + 3) {
                     if (type === 'h') return false;
                }
                if (y >= roomY && y < roomY + 3 && x > 0 && x < 3) {
                     if (type === 'v') return false;
                }

                return true;
            }

            isCellOccupiedInEditor(x, y) {
                if (this.endPos && this.endPos.x === x && this.endPos.y === y) return true;
                if (this.ghosts.some(g => g.x === x && g.y === y)) return true;
                if (this.items.some(i => i.x === x && i.y === y)) return true;
                return false;
            }

            eraseAtPos(pos) {
                const wall = this.getWallAtPos(pos.x, pos.y);
                if (wall && this.isWallEditable(wall)) {
                    if (wall.type === 'h') this.hWalls[wall.y][wall.x] = { type: 0, keys: 0 };
                    else this.vWalls[wall.y][wall.x] = { type: 0, keys: 0 };
                }

                const cellX = Math.floor(pos.x / this.cellSize);
                const cellY = Math.floor(pos.y / this.cellSize);
                if (!this.isPosInStartRoom(cellX, cellY)) {
                    if (this.endPos && this.endPos.x === cellX && this.endPos.y === cellY) {
                        this.endPos = null;
                    }
                    this.ghosts = this.ghosts.filter(g => g.x !== cellX || g.y !== cellY);
                    this.items = this.items.filter(i => i.x !== cellX || i.y !== cellY);
                }
                this.drawEditor();
            }

            handleCanvasClick(e) {
                if (this.state !== 'playing' || this.editor.active) return;
                this.stopAutoMove();

                const pos = this.getMousePos(e);
                const targetX = Math.floor(pos.x / this.cellSize);
                const targetY = Math.floor(pos.y / this.cellSize);

                if (targetX < 0 || targetX >= this.width || targetY < 0 || targetY >= this.height) return;
                
                const dx = targetX - this.player.x;
                const dy = targetY - this.player.y;

                if (Math.abs(dx) + Math.abs(dy) === 1) {
                    this.movePlayer(dx, dy);
                    return;
                }

                if (!this.seenCells[targetY][targetX] && !this.debugVision) return;

                const path = this.findPlayerPath(this.player, {x: targetX, y: targetY});
                
                if (path && path.length > 1) {
                    let currentStep = 1;
                    const move = () => {
                        if (currentStep >= path.length || this.state !== 'playing') {
                            this.stopAutoMove();
                            return;
                        }
                        const nextPos = path[currentStep];
                        const dx = nextPos.x - this.player.x;
                        const dy = nextPos.y - this.player.y;
                        this.movePlayer(dx, dy);
                        currentStep++;
                    };
                    move(); // First move is instant
                    if (path.length > 2) {
                        this.autoMoveInterval = setInterval(move, 200);
                    }
                }
            }

            stopAutoMove() {
                if (this.autoMoveInterval) {
                    clearInterval(this.autoMoveInterval);
                    this.autoMoveInterval = null;
                }
                if (this.dpadInterval) { 
                    clearInterval(this.dpadInterval);
                }
            }

            handleCanvasMouseDown(e) {
                if (!this.editor.active) return;
                
                this.editor.isDragging = true;
                this.editor.didDrag = false;

                const pos = this.getMousePos(e);

                if (this.editor.tool === 'wall') {
                    const wall = this.getWallAtPos(pos.x, pos.y);
                    if (wall && this.isWallEditable(wall)) {
                        this.editor.dragAxis = wall.type;
                        this.toggleWall(wall);
                        this.editor.lastDragPos = wall;
                    } else {
                        this.editor.dragAxis = null;
                    }
                } else if (this.editor.tool === 'eraser') {
                    this.eraseAtPos(pos);
                }
            }

            handleCanvasMouseMove(e) {
                if (!this.editor.active) return;

                if (!this.editor.isDragging) {
                    if (this.editor.tool === 'wall' || this.editor.tool === 'door' || this.editor.tool === 'lock') {
                        const pos = this.getMousePos(e);
                        const wall = this.getWallAtPos(pos.x, pos.y);
                        if (wall && this.isWallEditable(wall)) {
                            if (!this.editor.hoveredWall || this.editor.hoveredWall.x !== wall.x || this.editor.hoveredWall.y !== wall.y || this.editor.hoveredWall.type !== wall.type) {
                                this.editor.hoveredWall = wall;
                                this.drawEditor();
                            }
                        } else if (this.editor.hoveredWall) {
                            this.editor.hoveredWall = null;
                            this.drawEditor();
                        }
                    }
                    return;
                }

                this.editor.didDrag = true;
                this.editor.hoveredWall = null;

                if (this.editor.tool === 'wall' && this.editor.dragAxis) {
                    const pos = this.getMousePos(e);
                    let wall;
                    if (this.editor.dragAxis === 'h') {
                        const x = Math.floor(pos.x / this.cellSize);
                        const y = this.editor.lastDragPos.y;
                        wall = { type: 'h', x, y };
                    } else {
                        const y = Math.floor(pos.y / this.cellSize);
                        const x = this.editor.lastDragPos.x;
                        wall = { type: 'v', x, y };
                    }
                    
                    if (wall && this.isWallEditable(wall) && (wall.x !== this.editor.lastDragPos.x || wall.y !== this.editor.lastDragPos.y)) {
                        if (wall.type === 'h') this.hWalls[wall.y][wall.x] = { type: 1, keys: 0 };
                        else this.vWalls[wall.y][wall.x] = { type: 1, keys: 0 };
                        this.drawEditor();
                        this.editor.lastDragPos = wall;
                    }
                } else if (this.editor.tool === 'eraser') {
                    this.eraseAtPos(this.getMousePos(e));
                }
            }
            
            handleCanvasMouseUp(e) {
                if (!this.editor.active) return;

                if (this.editor.isDragging && !this.editor.didDrag) {
                    const pos = this.getMousePos(e);
                    const cellX = Math.floor(pos.x / this.cellSize);
                    const cellY = Math.floor(pos.y / this.cellSize);
                    
                    const wall = this.getWallAtPos(pos.x, pos.y);
                    if (wall && this.isWallEditable(wall)) {
                        if (this.editor.tool === 'door') {
                            if (wall.type === 'h') {
                                const currentType = this.hWalls[wall.y][wall.x].type;
                                this.hWalls[wall.y][wall.x] = { type: currentType === 2 ? 0 : 2, keys: 0 };
                            } else {
                                const currentType = this.vWalls[wall.y][wall.x].type;
                                this.vWalls[wall.y][wall.x] = { type: currentType === 2 ? 0 : 2, keys: 0 };
                            }
                        } else if (this.editor.tool === 'lock') {
                            const numStr = prompt('请输入锁需要的钥匙数量:', '0');
                            if (numStr !== null) {
                                const keys = parseInt(numStr);
                                if (!isNaN(keys) && keys >= 0) {
                                    if (wall.type === 'h') this.hWalls[wall.y][wall.x] = { type: 3, keys: keys };
                                    else this.vWalls[wall.y][wall.x] = { type: 3, keys: keys };
                                } else {
                                    this.showToast('请输入一个有效的非负整数。', 3000, 'error');
                                }
                            }
                        }
                    }

                    if (!this.isPosInStartRoom(cellX, cellY)) {
                        const existingItemIndex = this.items.findIndex(i => i.x === cellX && i.y === cellY);
                        const isOccupied = this.isCellOccupiedInEditor(cellX, cellY);

                        switch (this.editor.tool) {
                            case 'end':
                                if (!isOccupied || (this.endPos && this.endPos.x === cellX && this.endPos.y === cellY)) {
                                    this.endPos = { x: cellX, y: cellY };
                                }
                                break;
                            case 'ghost':
                                const existingGhostIndex = this.ghosts.findIndex(g => g.x === cellX && g.y === cellY);
                                if (existingGhostIndex > -1) {
                                    this.ghosts.splice(existingGhostIndex, 1);
                                } else if (!isOccupied) {
                                    this.ghosts.push({ x: cellX, y: cellY });
                                }
                                break;
                            case 'key':
                                if (existingItemIndex > -1 && this.items[existingItemIndex].type === 'key') {
                                    this.items.splice(existingItemIndex, 1);
                                } else if (!isOccupied) {
                                    this.items.push({ x: cellX, y: cellY, type: 'key' });
                                }
                                break;
                        }
                    }
                    this.drawEditor();
                }
                
                this.editor.isDragging = false;
                this.editor.didDrag = false;
                this.editor.dragAxis = null;
                this.editor.lastDragPos = null;
            }
            
            handleCanvasMouseLeave(e) {
                if (this.editor.hoveredWall) {
                    this.editor.hoveredWall = null;
                    this.drawEditor();
                }
                this.editor.isDragging = false;
                this.editor.didDrag = false;
                this.editor.dragAxis = null;
                this.editor.lastDragPos = null;
            }
            
            getWallAtPos(mouseX, mouseY) {
                const cs = this.cellSize;
                const tolerance = cs / 5;
                const gridX = mouseX / cs;
                const gridY = mouseY / cs;
                const x = Math.floor(gridX);
                const y = Math.floor(gridY);
                
                const nearHorizontal = Math.abs(gridY - Math.round(gridY)) * cs < tolerance;
                const nearVertical = Math.abs(gridX - Math.round(gridX)) * cs < tolerance;
                
                if (nearHorizontal && !nearVertical) {
                    return { type: 'h', x: x, y: Math.round(gridY) };
                }
                if (nearVertical && !nearHorizontal) {
                    return { type: 'v', x: Math.round(gridX), y: y };
                }
                return null;
            }
            
            toggleWall(wall) {
                const {x, y, type} = wall;
                if (type === 'h' && y >= 0 && y <= this.height && x >= 0 && x < this.width) {
                    this.hWalls[y][x].type = this.hWalls[y][x].type === 1 ? 0 : 1;
                } else if (type === 'v' && x >= 0 && x <= this.width && y >= 0 && y < this.height) {
                    this.vWalls[y][x].type = this.vWalls[y][x].type === 1 ? 0 : 1;
                }
                this.drawEditor();
            }

            // ==================================================
            //  UTILITIES (Pathfinding, Share Code)
            // ==================================================
            
            calculateDistances(startNode) {
                const distances = Array(this.height).fill(null).map(() => Array(this.width).fill(Infinity));
                const queue = [{ x: startNode.x, y: startNode.y, dist: 0 }];
                distances[startNode.y][startNode.x] = 0;

                while (queue.length > 0) {
                    const { x, y, dist } = queue.shift();
                    
                    const neighbors = [ {dx:0, dy:-1}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:-1, dy:0} ];
                    for (const {dx, dy} of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        
                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height) {
                            if (dx === 1 && (this.vWalls[y][x + 1].type === 1 || this.vWalls[y][x + 1].type === 3)) continue;
                            if (dx === -1 && (this.vWalls[y][x].type === 1 || this.vWalls[y][x].type === 3)) continue;
                            if (dy === 1 && (this.hWalls[y + 1][x].type === 1 || this.hWalls[y + 1][x].type === 3)) continue;
                            if (dy === -1 && (this.hWalls[y][x].type === 1 || this.hWalls[y][x].type === 3)) continue;
                            
                            if (distances[ny][nx] === Infinity) {
                                distances[ny][nx] = dist + 1;
                                queue.push({ x: nx, y: ny, dist: dist + 1 });
                            }
                        }
                    }
                }
                return distances;
            }
            
            findShortestPath(start, end) {
                const queue = [[{x: start.x, y: start.y}]];
                const visited = new Set([`${start.x},${start.y}`]);

                while (queue.length > 0) {
                    const path = queue.shift();
                    const { x, y } = path[path.length - 1];

                    if (x === end.x && y === end.y) {
                        return path;
                    }

                    const neighbors = [ {dx:0, dy:-1}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:-1, dy:0} ];
                    for (const {dx, dy} of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        const key = `${nx},${ny}`;

                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !visited.has(key)) {
                            if (dx === 1 && this.vWalls[y][x + 1].type > 0) continue;
                            if (dx === -1 && this.vWalls[y][x].type > 0) continue;
                            if (dy === 1 && this.hWalls[y + 1][x].type > 0) continue;
                            if (dy === -1 && this.hWalls[y][x].type > 0) continue;
                            
                            visited.add(key);
                            const newPath = [...path, {x: nx, y: ny}];
                            queue.push(newPath);
                        }
                    }
                }
                return null;
            }

            findPlayerPath(start, end) {
                const queue = [[{x: start.x, y: start.y}]];
                const visited = new Set([`${start.x},${start.y}`]);

                while (queue.length > 0) {
                    const path = queue.shift();
                    const { x, y } = path[path.length - 1];

                    if (x === end.x && y === end.y) {
                        return path;
                    }

                    const neighbors = [ {dx:0, dy:-1}, {dx:1, dy:0}, {dx:0, dy:1}, {dx:-1, dy:0} ];
                    for (const {dx, dy} of neighbors) {
                        const nx = x + dx;
                        const ny = y + dy;
                        const key = `${nx},${ny}`;

                        if (nx >= 0 && nx < this.width && ny >= 0 && ny < this.height && !visited.has(key)) {
                            if (!this.seenCells[ny][nx] && !this.debugVision) continue;
                            if (dx === 1 && (this.vWalls[y][x + 1].type === 1 || this.vWalls[y][x + 1].type === 3)) continue;
                            if (dx === -1 && (this.vWalls[y][x].type === 1 || this.vWalls[y][x].type === 3)) continue;
                            if (dy === 1 && (this.hWalls[y + 1][x].type === 1 || this.hWalls[y + 1][x].type === 3)) continue;
                            if (dy === -1 && (this.hWalls[y][x].type === 1 || this.hWalls[y][x].type === 3)) continue;
                            
                            visited.add(key);
                            const newPath = [...path, {x: nx, y: ny}];
                            queue.push(newPath);
                        }
                    }
                }
                return null;
            }           
            
            generateShareCode(isEditor = false) {
                try {
                    let mapSource;
                    if (isEditor) {
                        mapSource = {
                            w: this.width, h: this.height,
                            hw: this.hWalls, vw: this.vWalls,
                            e: this.endPos, g: this.ghosts, i: this.items,
                            gm: this.gameMode,
                            ih: parseInt(document.getElementById('editor-initial-health').value) || 5,
                            is: parseInt(document.getElementById('editor-initial-stamina').value) || 100
                        };
                    } else {
                        if (!this.mapData) return null;
                        mapSource = {
                            w: this.mapData.width, h: this.mapData.height,
                            hw: this.mapData.hWalls, vw: this.mapData.vWalls,
                            e: this.mapData.endPos, g: this.mapData.initialGhosts, i: this.mapData.items,
                            gm: this.gameMode, ih: this.initialHealth, is: this.initialStamina
                        };
                    }

                    const jsonString = JSON.stringify(mapSource);
                    const compressedData = pako.deflate(jsonString);
                    const binaryString = String.fromCharCode.apply(null, compressedData);
                    const shareCode = btoa(binaryString);
                    
                    return shareCode;

                } catch (e) {
                    console.error("Error generating compressed share code:", e);
                    this.showToast('生成分享码失败。', 3000, 'error');
                    return null;
                }
            }

            loadFromShareCode(code, isEditor = false) {
                if (!code) {
                    this.showToast('请输入分享码。', 3000, 'error');
                    return;
                }
                try {
                    const binaryString = atob(code);
                    const len = binaryString.length;
                    const bytes = new Uint8Array(len);
                    for (let i = 0; i < len; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }

                    const jsonString = pako.inflate(bytes, { to: 'string' });
                    const data = JSON.parse(jsonString);

                    if (!data.w || !data.h || !data.hw || !data.vw) {
                        throw new Error("Invalid map data structure");
                    }

                    const mapData = {
                        width: data.w, height: data.h,
                        hWalls: data.hw, vWalls: data.vw,
                        endPos: data.e || null,
                        initialGhosts: data.g || [],
                        items: data.i || []
                    };

                    const loadedMode = data.gm || 'exploration';
                    const loadedHealth = data.ih || 5;
                    const loadedStamina = data.is || 100;

                    if (isEditor) {
                        // *** 关键修复：改变了函数调用顺序 ***
                        // 1. 先调用 setGameMode 更新UI和内部状态
                        this.setGameMode(loadedMode, true); 
                        // 2. 再更新编辑器输入框的值
                        document.getElementById('editor-initial-health').value = loadedHealth;
                        document.getElementById('editor-initial-stamina').value = loadedStamina;

                        this.width = mapData.width;
                        this.height = mapData.height;
                        this.editorMapSizeInput.value = this.width;
                        this.cellSize = canvas.width / this.width;
                        this.hWalls = mapData.hWalls;
                        this.vWalls = mapData.vWalls;
                        this.endPos = mapData.endPos;
                        this.ghosts = mapData.initialGhosts;
                        this.items = mapData.items;
                        this.drawEditor();
                    } else {
                        // *** 关键修复：改变了函数调用顺序 ***
                        // 1. 先设置初始值
                        this.initialHealth = loadedHealth;
                        this.initialStamina = loadedStamina;
                        // 2. 再调用 setGameMode，它会正确地更新UI和内部状态
                        this.setGameMode(loadedMode);
                        // 3. 最后用已完全同步的状态启动游戏
                        this.startGame(mapData);
                    }
                    this.showToast('地图加载成功！', 2000, 'success');

                } catch (e) {
                    console.error("Error loading from compressed share code:", e);
                    this.showToast('加载分享码失败，格式不正确或已损坏。', 3000, 'error');
                }
            }

            // ==================================================
            //  HISTORY & UNDO SYSTEM (NEW)
            // ==================================================

            createSnapshot(isRevivalPoint = false) {
                // 创建一个包含所有可变游戏状态的快照
                return {
                    player: JSON.parse(JSON.stringify(this.player)),
                    ghosts: JSON.parse(JSON.stringify(this.ghosts)),
                    items: JSON.parse(JSON.stringify(this.items)),
                    hWalls: JSON.parse(JSON.stringify(this.hWalls)),
                    vWalls: JSON.parse(JSON.stringify(this.vWalls)),
                    isRevivalPoint: isRevivalPoint
                };
            }

            loadFromSnapshot(snapshot) {
                // 从快照恢复游戏状态，【必须】使用深拷贝来防止历史记录被后续操作污染
                this.player = JSON.parse(JSON.stringify(snapshot.player));
                this.ghosts = JSON.parse(JSON.stringify(snapshot.ghosts));
                this.items = JSON.parse(JSON.stringify(snapshot.items));
                this.hWalls = JSON.parse(JSON.stringify(snapshot.hWalls));
                this.vWalls = JSON.parse(JSON.stringify(snapshot.vWalls));
                
                // 恢复后立即刷新显示
                this.updateUIDisplays();
                this.draw();
            }

            recordHistory(isRevivalPoint = false) {
                // 如果当前指针不在历史记录的末尾 (意味着玩家撤销后走了新路)
                // 则需要截断旧的“未来”历史
                if (this.currentStep < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentStep + 1);
                    // 同时也要删除掉被截断的未来中的存档点
                    this.checkpoints = this.checkpoints.filter(cp => cp <= this.currentStep);
                }
                
                const snapshot = this.createSnapshot(isRevivalPoint);
                this.history.push(snapshot);
                this.currentStep++;
                
                this.updateHistoryButtons();
            }

            updateHistoryButtons() {
                const undoBtn = document.getElementById('undo-btn');
                const saveBtn = document.getElementById('save-btn');
                const rewindBtn = document.getElementById('rewind-btn');

                // 撤回按钮的可用逻辑
                const canUndo = this.currentStep > 0 && !this.history[this.currentStep].isRevivalPoint;
                undoBtn.disabled = !canUndo;

                // 存档按钮的可用逻辑
                const lastCheckpoint = this.checkpoints.length > 0 ? this.checkpoints[this.checkpoints.length - 1] : -1;
                const canSave = this.currentStep > lastCheckpoint;
                saveBtn.disabled = !canSave;

                // 回溯按钮的可用逻辑：检查是否存在一个存档点严格小于当前步数
                const canRewind = this.checkpoints.some(cp => cp < this.currentStep);
                rewindBtn.disabled = !canRewind;
            }

            handleUndo() {
                if (this.currentStep <= 0) return;
                if (this.history[this.currentStep].isRevivalPoint) {
                    this.showToast('无法撤回到上一次生命', 2000, 'error');
                    return;
                }
                
                this.currentStep--;
                this.loadFromSnapshot(this.history[this.currentStep]);
                this.updateHistoryButtons();
            }

            handleSave() {
                const lastCheckpoint = this.checkpoints.length > 0 ? this.checkpoints[this.checkpoints.length - 1] : -1;
                if (this.currentStep <= lastCheckpoint) {
                    this.showToast('请先移动后再存档', 2000, 'error');
                    return;
                }

                this.checkpoints.push(this.currentStep);
                this.showToast(`已在第 ${this.currentStep} 步创建存档`, 2000, 'success');
                this.updateHistoryButtons();
            }

            handleRewind() {
                // 步骤 1: 从所有存档点中，筛选出那些步数严格小于当前步数的存档点。
                const availableCheckpoints = this.checkpoints.filter(cp => cp < this.currentStep);

                // 步骤 2: 检查是否存在任何更早的存档点。
                if (availableCheckpoints.length === 0) {
                    // 如果一个都没有，说明已经无法再回溯了。
                    this.showToast('没有更早的存档点可供回溯', 2000, 'error');
                    return;
                }

                // 步骤 3: 在所有可用的存档点中，找到数值最大的那一个。
                // 这就是离当前位置最近的、更早的存档点。
                const targetStep = Math.max(...availableCheckpoints);

                // 步骤 4: 执行回溯。
                this.currentStep = targetStep;
                this.loadFromSnapshot(this.history[this.currentStep]);
                this.updateHistoryButtons();
                this.showToast(`已回溯至存档点 (第 ${targetStep} 步)`, 2000, 'success');
            }

            copyShareCode(isEditor = false) {
                const code = this.generateShareCode(isEditor);
                if (code) {
                    navigator.clipboard.writeText(code).then(() => {
                        this.showToast('分享码已复制到剪贴板！', 2000, 'success');
                    }, () => {
                        this.showToast('复制分享码失败。', 3000, 'error');
                    });
                } else {
                    this.showToast('无法生成分享码，请先创建地图。', 3000, 'error');
                }
            }
        }

        const game = new GhostMazeGame();
    });
    </script>
        <div id="dpad-controls" style="display: none;">
            <div id="dpad-up" class="dpad-btn">▲</div>
            <div id="dpad-left" class="dpad-btn">◀</div>
            <div id="dpad-grip"></div> <!-- 新增的拖动把手 -->
            <div id="dpad-right" class="dpad-btn">▶</div>
            <div id="dpad-down" class="dpad-btn">▼</div>
        </div>
    </body>
</html>